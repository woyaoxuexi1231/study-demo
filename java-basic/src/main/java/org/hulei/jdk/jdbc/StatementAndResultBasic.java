package org.hulei.jdk.jdbc;

import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Scanner;
import java.util.function.Consumer;

/**
 * @author hulei
 * @since 2024/9/8 15:48
 */

@Slf4j
public class StatementAndResultBasic {

    public static Connection connection = ConnectFactory.getConnection();
    public static Statement statement = ConnectFactory.getStatement();
    public static Statement updatealeStatement = ConnectFactory.getUpdatealeStatement();

    @SneakyThrows
    public static void main(String[] args) {
        // doExecuteUpdate(getExecuteUpdate());
        // doExecuteQuery();

        // 精度丢失问题
        bigDecimal();
    }

    public static void bigDecimal() {
        doExecuteUpdate(new Consumer<Statement>() {
            @SneakyThrows
            @Override
            public void accept(Statement statement) {
                statement.executeUpdate("update customers set creditLimit = 124.126514234 where customerNumber = 103");
            }
        });
    }

    @SneakyThrows
    public static void doExecuteQuery() {

        String usersQuery = "select id,name from users limit 0,1;";
        String biguserQuery = "select * from biguser limit 0,1;";

        ResultSet resultSet = updatealeStatement.executeQuery(usersQuery);
        while (resultSet.next()) {
            // 对于resultSet的下标索引它是根据sql列的返回顺序决定的,默认从1开始而不是0
            // log.info("id: {}, name: {}", resultSet.getLong(1), resultSet.getString(2));
            // 使用列名来获取元素是一种更安全更方便的操作方式,这些方法会进行合理的转换 如果数据库类型是double类型,但是我们使用result.getString来接收,jdbc会进行合理的类型转换
            log.info("id: {}, name: {}", resultSet.getLong("id"), resultSet.getString("name"));
            log.info("从 getObject 获取 name: {}", resultSet.getObject("name", String.class));
            resultSet.updateString("name", "updateString");
            // 想要开启这个更新,必须打开可更新的Statement
            // 这里实际会根据主键更新: UPDATE `test`.`users` SET `test`.`users`.`id`=1,`test`.`users`.`name`='updateString' WHERE `test`.`users`.`id`<=>1
            resultSet.updateRow();
            connection.commit();
            // log.info("updateString 之后再获取 name: {}",resultSet.getObject("name", String.class));
        }

        // 同时执行两个sql是会报错的,因为单个statement只能持有一个ResultSet,要得到多个结果只能分开用多个statement来执行得到结果
        // statement.executeQuery(usersQuery + biguserQuery);
        // statement.execute(usersQuery + biguserQuery);

        // 对于返回更新的数量函数,用于返回最近一次查询的更改的数据的数量,如果sql返回的是ResultSet或者没有更新数据库都返回-1
        System.out.println(updatealeStatement.getUpdateCount());

        // 批量执行,但是查询语句不支持这个操作,批量执行只能放在更新语句上
        // statement.addBatch(usersQuery);
        // statement.addBatch(usersQuery);
        // statement.executeBatch();
    }

    /**
     * executeUpdate相关测试
     *
     * @return consumer
     */
    public static Consumer<Statement> getExecuteUpdate() {
        return new Consumer<Statement>() {
            @SneakyThrows
            @Override
            public void accept(Statement statement) {

                String insertSQL = "insert into users(name) select 'zhangsan'";
                String updateSQL = "update users set name = 'zhangsan' where id = 34";

                /*
                方法返回的结果是受到sql影响的行数,或者对不返回行数的语句返回0.
                executeUpdate可以执行 insert,update,delete之类的操作,也可以执行create table和drop table之类的数据定义语句.
                执行查询时必须使用executeQuery.
                execute可以执行任意的sql,此方法通常只用于有用户提供的交互式查询
                 */
                int updateCount = statement.executeUpdate(updateSQL);
                log.info("更新了 {} 条数据", updateCount);
                /*
                Statement.RETURN_GENERATED_KEYS能有效得帮助我们获取自动生成的键
                executeUpdate有多个重载的方法,目前除了executeUpdate(String sql, int autoGeneratedKeys)能够成功外
                剩下两个都不知道怎么用 todo,方法标签都表明 This method cannot be called on a PreparedStatement or CallableStatement.
                 */
                int insertCount = statement.executeUpdate(insertSQL, Statement.RETURN_GENERATED_KEYS);
                // ResultSet接口初始化时被设定在第一行之前的位置,所以在访问元素的时候必须调用next方法将它移动到第一行
                // log.info("插入了 {} 条数据,生成的键为: {}", count, statement.getGeneratedKeys().getLong(1)); // 此处报错 java.sql.SQLException: Before start of result set
                ResultSet generatedKeys = statement.getGeneratedKeys();
                if (generatedKeys.next()) {
                    long id = generatedKeys.getLong(1);
                    log.info("生成的键为: {}", id);
                }
                log.info("插入了 {} 条数据", insertCount);

            }
        };
    }

    /**
     * 事务的提交和回滚
     *
     * @param consumer 执行的sql逻辑
     */
    public static void doExecuteUpdate(Consumer<Statement> consumer) {
        // ConnectFactory已经关闭了默认的数据库提交行为
        try {
            boolean isRollback = false;
            try {
                // 执行操作
                consumer.accept(statement);
            } catch (Exception e) {
                log.error("execute error,", e);
                isRollback = true;
            }
            // 判断是否需要回滚
            if (isRollback) {
                connection.rollback();
            } else if (!connection.isReadOnly()) {
                connection.commit();
            }
        } catch (SQLException e) {
            log.info("execute error,", e);
        }
    }
}
