---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by User.
--- DateTime: 2024/12/30 11:43
---

local core = require("apisix.core")
local limit_count = require("resty.limit.count")
local apisix_plugin = require("apisix.plugin")
local cjson = require "cjson"
local http = require("socket.http")

local ngx = ngx
local ngx_time = ngx.time
local ipairs = ipairs
local setmetatable = setmetatable

local plugin_name = "custom-limit"

-- 创建一个新的 LRU（Least Recently Used）缓存对象，主要用于插件中的数据缓存和管理。
local lrucache = core.lrucache.new({
    type = 'plugin', serial_creating = true,
})

-- 定义插件的基本信息
local _M = {
    -- 插件版本。
    version = 0.5,
    -- 插件优先级，值越高优先级越高。
    priority = 1001,
    name = plugin_name,
    schema = {
    }
}

local mt = { __index = _M }

local function set_endtime(self, id_number, key, time_window)
    -- set an end time
    local end_time = ngx_time() + time_window
    -- save to dict by key
    local success, err = self.limits[id_number].dict:set(key, end_time, time_window)

    if not success then
        core.log.error("dict set key ", key, " error: ", err)
    end

    local reset = time_window
    return reset
end

local function read_reset(self, id_number, key)
    local end_time = (self.limits[id_number].dict:get(key) or 0)
    local reset = end_time - ngx_time()
    if reset < 0 then
        reset = 0
    end
    return reset
end

-- 根据用户的统一认证号和上下文信息生成一个特定的 key
local function gen_limit_key(id_number, conf, ctx)

    local conf_type = ctx.conf_type_without_consumer or ctx.conf_type
    local conf_id = ctx.conf_id_without_consumer or ctx.conf_id
    local new_key = conf_type .. conf_id .. ':' .. apisix_plugin.conf_version(conf)
            .. ':' .. id_number
    if conf._vid then
        -- conf has _vid means it's from workflow plugin, add _vid to the key
        -- so that the counter is unique per action.
        return new_key .. ':' .. conf._vid
    end

    return new_key
end

local function create_new(id_number, count, daily_visited_num, conf, ctx)

    local self = {
        -- 具体的插件配置项，这个内部会保存一个 OpenResty 的限流器，以及对应的各项限流参数
        limits = {}
    }

    local key = gen_limit_key(id_number, conf, ctx)

    core.log.warn("custom-limit-plugin initialing: id_number: ", id_number, " count: ", count, " key: ", key, " daily_visited_num: ", daily_visited_num)

    -- 创建一个新的限流器实例
    -- 入参: 1.限流器键前缀 2.允许的最大请求数量 3.时间窗口内的大小
    local lim, err = limit_count.new("plugin-" .. plugin_name, count, 100)

    -- 将限流器和其他配置项存入 self.limits 下，每个不同的用户拥有不同的限流器
    self.limits[id_number] = {
        -- 刚才创建的限流器实例
        limit_count = lim,
        -- 当前用户的限制访问次数 TODO 目前来说这里没考虑限流数量变化的情况，如果限流数量变化，那么限流器也需要更新的
        count = count,
        daily_visited_num = daily_visited_num,
        -- nginx共享内存，这个会用于计算目前的限流次数
        dict = ngx.shared["plugin-" .. plugin_name .. "-reset-header"]
    }

    core.log.warn("custom-limit-plugin successful: id_number: ", id_number, " count: ", count, " key: ", key, " daily_visited_num: ", daily_visited_num)

    return setmetatable(self, mt)
end

local function gen_limit_obj(id_number, count, daily_visited_num, conf, ctx)
    -- 用于管理插件上下文缓存的函数，是一个用于管理插件上下文缓存的函数。它主要用于在插件上下文中创建或获取缓存对象，以确保缓存项的高效利用和一致性。
    -- core.lrucache.plugin_ctx(lrucache, ctx, extra_key, create_func, ...)
    -- 各参数信息如下：
    -- 1. lrucache：LRU 缓存对象，这是由 core.lrucache.new 创建的缓存实例。
    -- 2. ctx：插件上下文对象，包含当前请求的相关信息。这个对象用于在请求的生命周期内存储和共享数据。
    -- 3. extra_key：一个附加键，用于唯一标识缓存项。这个键通常基于插件的配置和请求上下文生成，以确保每个缓存项在特定上下文中是唯一的。
    -- 4. create_func：一个函数，用于创建缓存项。如果缓存中没有找到对应的项，会调用这个函数来创建新项。这个函数通常包含创建对象所需的逻辑。
    -- 5. ...（可变参数）：传递给 create_func 的其他参数。这些参数通常包含创建缓存项所需的额外信息。
    return core.lrucache.plugin_ctx(lrucache, ctx, plugin_name, create_new, id_number, count, daily_visited_num, conf, ctx)
end

function _M.incoming(self, id_number, count, key, commit, conf, cost)

    -- 这里调用 OpenResty 的 incoming 方法
    -- incoming 方法的作用是记录一次请求并检查当前请求是否超出限流阈值。
    -- 入参：
    -- - key：表示限流键，用于标识请求来源。通常可以使用用户 ID 或 IP 地址。
    -- - commit：布尔值，指示是否实际增加计数。如果为 true，则增加计数；如果为 false，则只是模拟计数不实际增加。
    -- - cost：增加的计数值
    -- 出参：
    -- - delay: 延迟时间
    -- - remaining: 剩余请求次数
    local delay, remaining = self.limits[id_number].limit_count:incoming(key, commit, cost)
    local reset

    if remaining == count - cost then
        reset = set_endtime(self, id_number, key, 100)
    else
        reset = read_reset(self, id_number, key)
    end

    return delay, remaining, reset
end


-- access 方法是 apisix 的插件规范内的方法，http请求触发后，如果启动了该插件，会按照插件顺序依次调用插件的 access 方法
function _M.access(conf, ctx)

    -- 获取 token 参数
    local token = core.request.header(ctx, "token")
    if not token then
        core.log.error("token header is missing")
        return 401, { error_msg = "token header required" }
    end

    -- 获取当前请求的路径 路径格式为 /code/version
    -- 获取当前请求的路由名称
    local route_name = ctx.matched_route and ctx.matched_route.value and ctx.matched_route.value.name
    if route_name then
        core.log.warn("Current request route name: ", route_name)
    else
        core.log.warn("Route name not found")
    end

    -- TODO 这里应该调用 共享服务的 http 接口根据 token 获取具体的用户名和目录信息
    -- token 解析的结果是 统一认证号:用户名:用户部门id:用户部门名称:ip限制:过期时间
    local url = "http://localhost:10090/decode-token?token=" .. token .. "&path=" .. route_name;

    local response, status = http.request(url)

    if status == 200 then

        core.log.warn("response: ", response)

        local rsp_table = cjson.decode(response)

        local id_number = rsp_table.data.idNumber;
        local is_admin = rsp_table.data.isAdmin;
        local visited_freq = tonumber(rsp_table.data.visitedFreq);
        local daily_visited_num = tonumber(rsp_table.da.data.dailyVisitedNum);

        core.log.warn("visited_freq: ", visited_freq)
        core.log.warn("daily_visited_num: ", daily_visited_num)

        if (is_admin == false) then

            -- 非管理员并且限制访问次数为0，那么代表无权限，直接 401
            if (visited_freq == 0) then
                return 401
            end

            -- 获取限流器对象，这里其实拿到的是缓存中生成的这个对象自己
            local lim, err = gen_limit_obj(id_number, visited_freq, daily_visited_num, conf, ctx)
            if not lim then
                core.log.error("failed to fetch limit.count object: ", err)
                if conf.allow_degradation then
                    return
                end
                return 500
            end

            -- 获取一个限流 key
            local key = gen_limit_key(id_number, conf, ctx)
            core.log.warn("limit-key: ", key)

            local delay, remaining, reset
            -- 这里调用的是本对象的 incoming
            delay, remaining, reset = lim:incoming(id_number, visited_freq, key, true, conf, 1)

            core.log.warn("custom-limit-plugin access delay: ", delay)
            core.log.warn("custom-limit-plugin access remaining: ", remaining)
            core.log.warn("custom-limit-plugin access reset: ", reset)

            if delay == nil then
                local err = remaining
                if err == "rejected" then
                    return 503;
                end

                core.log.error("failed to limit count: ", err)
                if conf.allow_degradation then
                    return
                end
                return 500, { error_msg = "failed to limit count" }
            end
        end

    else
        core.log.error("HTTP request failed with status code: " .. status)
        return 500;
    end


end

return _M
