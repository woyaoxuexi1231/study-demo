---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by User.
--- DateTime: 2024/12/30 11:43
---

local core = require("apisix.core")
local limit_count = require("resty.limit.count")
local apisix_plugin = require("apisix.plugin")
local cjson = require "cjson"
local http = require("socket.http")
local socket = require("socket")

local ngx = ngx
local ngx_time = ngx.time
local ngx_today = ngx.today
local ipairs = ipairs
local setmetatable = setmetatable

local plugin_name = "share-limit"

-- 创建一个新的 LRU（Least Recently Used）缓存对象，主要用于插件中的数据缓存和管理。
local lrucache = core.lrucache.new({
    type = 'plugin', serial_creating = true,
})

-- 定义插件的基本信息
local _M = {
    -- 插件版本。
    version = 0.5,
    -- 插件优先级，值越高优先级越高。
    priority = 1001,
    name = plugin_name,
    schema = {
    }
}

local mt = { __index = _M }

local function set_endtime(self, id_number, key, time_window)
    -- set an end time
    local end_time = ngx_time() + time_window
    -- save to dict by key
    local success, err = self.limits[id_number].dict:set(key, end_time, time_window)

    if not success then
        core.log.error("dict set key ", key, " error: ", err)
    end

    local reset = time_window
    return reset
end

local function read_reset(self, id_number, key)
    local end_time = (self.limits[id_number].dict:get(key) or 0)
    local reset = end_time - ngx_time()
    if reset < 0 then
        reset = 0
    end
    return reset
end

local function get_today_date()
    -- 获取当前的日期字符串，格式为 YYYY-MM-DD
    return ngx_today()
end

-- 根据用户的统一认证号和上下文信息生成一个特定的 key
local function gen_limit_key(id_number, conf, ctx)

    local conf_type = ctx.conf_type_without_consumer or ctx.conf_type
    local conf_id = ctx.conf_id_without_consumer or ctx.conf_id
    local new_key = conf_type .. conf_id .. ':' .. apisix_plugin.conf_version(conf)
            .. ':' .. id_number
    if conf._vid then
        -- conf has _vid means it's from workflow plugin, add _vid to the key
        -- so that the counter is unique per action.
        return new_key .. ':' .. conf._vid
    end

    return new_key
end

local function create_new(id_number, visited_freq, daily_visited_num, conf, ctx)

    local self = {
        -- 具体的插件配置项，这个内部会保存一个 OpenResty 的限流器，以及对应的各项限流参数
        limits = {}
    }

    local key = gen_limit_key(id_number, conf, ctx)

    core.log.warn("custom-limit-plugin initialing: id_number: ", id_number, " visited_freq: ", visited_freq, " key: ", key, " daily_visited_num: ", daily_visited_num)

    -- 将限流器和其他配置项存入 self.limits 下，每个不同的用户拥有不同的限流器
    self.limits[id_number] = {
        -- 创建一个新的限流器实例
        -- 入参: 1.限流器键前缀 2.允许的最大请求数量 3.时间窗口内的大小
        limit_count = limit_count.new("plugin-" .. plugin_name, visited_freq, 100),
        -- 当前用户的限制访问次数 TODO 目前来说这里没考虑限流数量变化的情况，如果限流数量变化，那么限流器也需要更新的
        count = visited_freq,
        -- 每日访问量
        daily_visited_num = daily_visited_num,
        -- nginx共享内存，这个会用于计算目前的限流次数
        dict = ngx.shared["plugin-" .. plugin_name .. "-reset-header"],
        daily_dict = ngx.shared["plugin-" .. plugin_name .. "-daily"]
    }

    core.log.warn("custom-limit-plugin successful: id_number: ", id_number, " visited_freq: ", visited_freq, " key: ", key, " daily_visited_num: ", daily_visited_num)

    return setmetatable(self, mt)
end

local function gen_limit_obj(id_number, visited_freq, daily_visited_num, conf, ctx)
    -- 用于管理插件上下文缓存的函数，是一个用于管理插件上下文缓存的函数。它主要用于在插件上下文中创建或获取缓存对象，以确保缓存项的高效利用和一致性。
    -- core.lrucache.plugin_ctx(lrucache, ctx, extra_key, create_func, ...)
    -- 各参数信息如下：
    -- 1. lrucache：LRU 缓存对象，这是由 core.lrucache.new 创建的缓存实例。
    -- 2. ctx：插件上下文对象，包含当前请求的相关信息。这个对象用于在请求的生命周期内存储和共享数据。
    -- 3. extra_key：一个附加键，用于唯一标识缓存项。这个键通常基于插件的配置和请求上下文生成，以确保每个缓存项在特定上下文中是唯一的。
    -- 4. create_func：一个函数，用于创建缓存项。如果缓存中没有找到对应的项，会调用这个函数来创建新项。这个函数通常包含创建对象所需的逻辑。
    -- 5. ...（可变参数）：传递给 create_func 的其他参数。这些参数通常包含创建缓存项所需的额外信息。
    return core.lrucache.plugin_ctx(lrucache, ctx, plugin_name, create_new, id_number, visited_freq, daily_visited_num, conf, ctx)
end

function _M.validate_visited_freq(self, id_number, count, key, commit, conf, cost)

    -- 这里调用 OpenResty 的 incoming 方法
    -- incoming 方法的作用是记录一次请求并检查当前请求是否超出限流阈值。
    -- 入参：
    -- - key：表示限流键，用于标识请求来源。通常可以使用用户 ID 或 IP 地址。
    -- - commit：布尔值，指示是否实际增加计数。如果为 true，则增加计数；如果为 false，则只是模拟计数不实际增加。
    -- - cost：增加的计数值
    -- 出参：
    -- - delay: 延迟时间
    -- - remaining: 剩余请求次数
    local delay, remaining = self.limits[id_number].limit_count:incoming(key, commit, cost)
    local reset

    if remaining == count - cost then
        reset = set_endtime(self, id_number, key, 100)
    else
        reset = read_reset(self, id_number, key)
    end

    return delay, remaining, reset
end

local function parse_req(conf, ctx)

    local page_size = 10;

    -- 读取请求体
    ngx.req.read_body()

    -- 获取请求体内容
    local body = ngx.req.get_body_data()

    if not body then
        core.log.error("failed to get request body, page_size will be 10")
        return page_size;
    end

    -- 解析 JSON 数据
    local post_args, err = cjson.decode(body)
    if not post_args then
        core.log.error("failed to decode JSON, page_size will be 10, : ", err)
        return page_size;
    end

    -- 处理 JSON 数据
    if not post_args.pageSize then
        core.log.error("failed to get the page_size param, page_size will be 10")
        return page_size;
    else
        return post_args.pageSize;
    end

end

-- access 方法是 apisix 的插件规范内的方法，http请求触发后，如果启动了该插件，会按照插件顺序依次调用插件的 access 方法
function _M.access(conf, ctx)

    ------------------------------------------------ 获取校验 token 的 url 参数 -------------------------------------------------
    local attr = apisix_plugin.plugin_attr(plugin_name)
    if attr then
        local decode_token_url = attr.decode_token_url
        if decode_token_url then
            core.log.warn("成功获取解码token的url参数: ", decode_token_url)
        else
            core.log.error("未能获取解码token的url配置参数: decode_token_url 不存在")
            return 401, { error_msg = "please check apisix config, decode_token_url must not be null" }
        end
    else
        core.log.error("未能获取插件配置")
        return 401, { error_msg = "please check apisix config, decode_token_url must not be null" }
    end



    ------------------------------------------------ 必要参数前置校验 -------------------------------------------------
    --
    -- 获取 token 参数
    local token = core.request.header(ctx, "token")
    if not token then
        core.log.error("token header is missing")
        return 401, { error_msg = "token header required" }
    end

    -- 获取当前请求的路径 路径格式为 /code/version
    -- 获取当前请求的路由名称
    local route_path = ngx.var.uri
    if route_path then
        core.log.warn("Current request route path: ", route_path)
    else
        core.log.warn("Route path not found")
        return 401, { error_msg = "Route path is not illegal for this plugin(share-limit)" }
    end


    ------------------------------------------------ 流量控制校验 -------------------------------------------------
    --
    -- 解码token，解析的结果是 统一认证号:用户名:用户部门id:用户部门名称:ip限制:过期时间
    local url = "http://192.168.3.251:19998/api/share-service/decode-token?token=" .. token .. "&path=" .. route_path;
    local response, status = http.request(url)
    if status == 200 then

        core.log.warn("response: ", response)
        local rsp_table = cjson.decode(response)

        local id_number = rsp_table.data.idNumber;
        local is_admin = rsp_table.data.isAdmin;
        local visited_freq = tonumber(rsp_table.data.visitedFreq);
        local daily_visited_num = tonumber(rsp_table.data.dailyVisitedNum);
        local expire_time_millis = tonumber(rsp_table.data.expireTimeMillis);
        local current_time_millis = tonumber(rsp_table.data.currentTimeMillis);

        if (expire_time_millis < current_time_millis) then
            return 401, { error_msg = "current token's has expired!" }
        end

        if (is_admin == false) then

            core.log.warn("current user is not admin, begin to validate")

            -- 非管理员并且限制访问次数为0，那么代表无权限，直接 401
            if (visited_freq == 0) then
                return 401, { error_msg = "current user's visited_freq is 0!" }
            end

            -- 获取限流器对象，这里其实拿到的是缓存中生成的这个对象自己
            local lim, lim_err = gen_limit_obj(id_number, visited_freq, daily_visited_num, conf, ctx)
            if not lim then
                core.log.error("failed to fetch limit.count object: ", lim_err)
                return 500, { error_msg = "failed to fetch limit.count object, this is a plugin internal error!" }
            end


            -- 获取一个限流 key
            local key = gen_limit_key(id_number, conf, ctx)
            core.log.warn("current user's limit-key: ", key)

            ------------------------------------------------ 校验日访问量 -------------------------------------------------

            -- 校验日访问量是否会超过上限
            local page_size = parse_req(conf, ctx)
            -- 获取每日访问计数
            local daily_key = key .. "-" .. get_today_date()
            local daily_count = lim.limits[id_number].daily_dict:get(daily_key) or 0
            core.log.warn("current used daily_count: ", daily_count, " total daily_count: ", daily_visited_num)
            -- 检查每日访问限制
            if (daily_count + page_size) > daily_visited_num then
                return 429, { error_msg = "Daily visit limit reached" }
            end
            -- 更新每日访问计数
            local new_daily_count, new_daily_count_err = lim.limits[id_number].daily_dict:incr(daily_key, page_size, 0, 86400)
            if not new_daily_count then
                core.log.error("failed to increment daily visit count: ", new_daily_count_err)
                return 500, { error_msg = "failed to increment daily visit count" }
            end


            ------------------------------------------------ 校验秒访问频率 -------------------------------------------------

            local delay, remaining, reset
            -- 这里调用的是本对象的 incoming
            delay, remaining, reset = lim:validate_visited_freq(id_number, visited_freq, key, true, conf, 1)

            core.log.warn("share-limit-plugin current user's access delay: ", delay)
            core.log.warn("share-limit-plugin current user's access remaining: ", remaining)
            core.log.warn("share-limit-plugin current user's access reset: ", reset)

            if delay == nil then
                local err = remaining
                if err == "rejected" then
                    return 503;
                end

                core.log.error("failed to limit count: ", err)
                if conf.allow_degradation then
                    return
                end
                return 500, { error_msg = "failed to limit count" }
            end
        end
    else
        -- 获取限流信息失败，这里网关也抛出 500
        core.log.error("share-limit plugin get limit info error!" .. status)
        return 500, { error_msg = "share-limit plugin get limit info error!" };
    end


end

return _M
