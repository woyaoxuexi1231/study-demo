<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd
       http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx.xsd">

    <!-- <context:component-scan base-package="com.hundsun.demo.spring"></context:com> -->

    <!-- spring相关的配置信息 -->
    <!-- BeanFactoryPostProcessor -->
    <!-- 配置如果实现IgnoreBean接口,那么这个bean的自动注入将不会生效 -->
    <bean class="com.hundsun.demo.spring.init.processor.IgnoreBeanFactoryPostProcessor"/>
    <bean class="com.hundsun.demo.spring.init.processor.IgnoreBean"/>

    <!-- BeanPostProcessor -->
    <!-- <bean class="com.hundsun.demo.spring.init.processor.CustomBeanPostProcessor"/> -->
    <!-- <bean class="com.hundsun.demo.spring.init.processor.PrintMergedBeanDefinitionPostProcessor"/> -->
    <!-- <bean class="com.hundsun.demo.spring.init.processor.PrintInstantiationAwareBeanPostProcessor"/> -->
    <!-- <bean class="com.hundsun.demo.spring.init.processor.PrintSmartInstantiationAwareBeanPostProcessor"/> -->

    <!-- 当注入MySQLService的实现类的时候,全部改成注入MySQLServiceProxy而不是MySQLServiceImpl -->
    <bean class="com.hundsun.demo.spring.init.processor.ResolvableDependencyPostProcessor"/>
    <bean name="mySQLServiceImpl" class="com.hundsun.demo.spring.jdk.pattern.structural.proxy.MySQLServiceImpl"/>
    <bean name="mySQLServiceProxy" class="com.hundsun.demo.spring.jdk.pattern.structural.proxy.normal.MySQLServiceProxy">
        <property name="mySqlService" ref="mySQLServiceImpl"/>
    </bean>

    <!-- spring监听机制,由 ApplicationListener + ApplicationEvent 实现 -->
    <bean class="com.hundsun.demo.spring.init.listener.SimpleListener"/>

    <!-- Spring通过三级缓存来解决循环依赖的问题 -->
    <!-- Q1: 不过三级缓存确实可以解决循环依赖的问题, 但是我无法回答的是为什么要用三级缓存, 因为看上去二级缓存就可以解决问题了, 三级缓存似乎有点多余, 它肯定有更多的用途... 2023-2-10 -->
    <!-- A1: 二级缓存确实可以解决循环依赖的问题, 但是如果我们加入 Spring AOP 的话, 二级缓存就无法解决了, 三级缓存解决了代理对象的注入问题 -->
    <bean name="positiveBean" class="com.hundsun.demo.spring.init.circle.PositiveBean">
        <property name="negativeBean" ref="negativeBean"/>
        <!-- <constructor-arg name="negativeBean" ref="negativeBean"/> -->
        <!-- <lookup-method name="getNegativeBean" bean="negativeBean"/> -->
    </bean>
    <bean name="negativeBean" class="com.hundsun.demo.spring.init.circle.NegativeBean">
        <property name="positiveBean" ref="positiveBean"/>
        <!-- <constructor-arg name="positiveBean" ref="positiveBean"/> -->
    </bean>
    <bean name="circleBean" class="com.hundsun.demo.spring.init.circle.CircleBean">
        <property name="circleBean" ref="circleBean"/>
        <property name="name" value="first"/>
    </bean>

    <!-- ##################################################################################### -->
    <!-- ##################################### Spring AOP #################################### -->
    <!-- ##################################################################################### -->
    <!-- 用于启用 AspectJ 自动代理功能。 -->
    <!-- Spring 将会自动检测并创建应用程序中使用了 AspectJ 注解的 bean，并将其装配为代理对象，以便应用程序中的切面可以对这些对象进行增强。 -->
    <aop:aspectj-autoproxy/>
    <!-- 这是一个AspectJ的bean,如果不开启上面的配置,那么这个类将不会被增强 -->
    <bean class="com.hundsun.demo.commom.core.aop.DoneTimeAspect"/>
    <!-- 用于支持基于注解的 AspectJ 切面编程-->
    <!-- <bean class="org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator"> -->
    <!--     &lt;!&ndash; 配置指示 Spring 使用 CGLIB 来创建代理对象，而不是标准的 Java 接口代理。 &ndash;&gt; -->
    <!--     <property name="proxyTargetClass" value="true"/> -->
    <!-- </bean> -->


    <!-- ##################################################################################### -->
    <!-- ################################### Spring 多数据源 ################################### -->
    <!-- ##################################################################################### -->
    <!-- 先定义三套数据库 -->
    <bean id="masterDataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url"
                  value="jdbc:mysql://192.168.80.128:3306/yiibaidb?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;serverTimezone=Asia/Shanghai"/>
        <property name="username" value="root"/>
        <property name="password" value="123456"/>
    </bean>
    <bean id="secondDataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url"
                  value="jdbc:mysql://192.168.80.128:3306/yiibaidb?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;serverTimezone=Asia/Shanghai"/>
        <property name="username" value="root"/>
        <property name="password" value="123456"/>
    </bean>
    <bean id="thirdDataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url"
                  value="jdbc:mysql://192.168.80.128:3306/yiibaidb?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;serverTimezone=Asia/Shanghai"/>
        <property name="username" value="root"/>
        <property name="password" value="123456"/>
    </bean>
    <!-- 用于切换动态数据源的 AbstractRoutingDataSource -->
    <bean id="dataSource" class="com.hundsun.demo.spring.db.dynamicdb.DynamicDataSource">
        <property name="defaultTargetDataSource" ref="masterDataSource"/>
        <property name="targetDataSources">
            <map key-type="com.hundsun.demo.spring.db.dynamicdb.DynamicDataSourceType">
                <entry key="MASTER" value-ref="masterDataSource"/>
                <entry key="SECOND" value-ref="secondDataSource"/>
                <entry key="THIRD" value-ref="thirdDataSource"/>
            </map>
        </property>
    </bean>
    <!-- 一个注入AbstractRoutingDataSource的JdbcTemplate -->
    <bean id="multipleDataSourceJdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"/>
    </bean>
    <!-- 测试多数据源的监听器 -->
    <bean class="com.hundsun.demo.spring.db.dynamicdb.MultipleDataSourceTestListener">
        <!-- 注入dynamicTestService这个业务对象,声明信息在下面 -->
        <property name="dynamicTestService" ref="dynamicTestService"/>
    </bean>

    <!-- ##################################################################################### -->
    <!-- ####################################### 事务管理 ###################################### -->
    <!-- ##################################################################################### -->
    <!-- 这是一个事务管理器,有一个dataSource的属性,即指定这个事务管理器应该用哪个数据源来管理事务 -->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <!-- 绑定对哪个数据源生效 -->
        <property name="dataSource" ref="dataSource"/>
    </bean>
    <!-- 有了事务管理器还不够,事务管理器需要知道在哪里开启事务才行,并且需要知道事务隔离级别之类的属性,所以有了TransactionInterceptor -->
    <!-- 这个Bean是Spring事务管理的关键，它定义了事务的属性，比如事务的传播行为。-->
    <!-- 这里，它引用了transactionManager（需要在其他地方定义）来管理事务，并且设置了事务属性 -->
    <bean id="transactionInterceptor" class="org.springframework.transaction.interceptor.TransactionInterceptor">
        <!-- 被配置为使用transactionManager这个Bean来管理事务。 -->
        <property name="transactionManager" ref="transactionManager"/>
        <!-- 这部分配置定义了哪些方法应该在事务的环境下执行，以及这些事务应该遵循的规则。 -->
        <property name="transactionAttributes">
            <props>
                <!-- multipleDataSourceTransaction方法是测试多数据源DynamicTestService的一个方法 -->
                <!-- 指定multipleDataSourceTransaction方法（或更可能是一系列方法的模式）需要遵循的事务传播行为为PROPAGATION_REQUIRE -->
                <prop key="multipleDataSourceTransaction">PROPAGATION_REQUIRED</prop>
            </props>
        </property>
    </bean>
    <!-- 事务管理器现在都定义好了,但是业务对象依旧不具备事务特性,我们需要通过生成代理对象来拦截业务对象,使其在业务方法外包裹一层事务逻辑来实现事务 -->
    <!-- 这是一个实际的业务对象 -->
    <bean name="DynamicTestServiceTarget" class="com.hundsun.demo.spring.db.dynamicdb.DynamicTestServiceImpl" autowire="byName"/>
    <!-- ProxyFactoryBean可以用来为目标对象创建一个代理，这个代理可以实现相同的接口或继承相同的类，而且可以在目标方法的调用前后添加额外的处理逻辑，这种技术通常用于事务管理、日志记录、安全控制等方面。 -->
    <!-- Spring AOP默认使用JDK动态代理和CGLIB代理两种方式来生成代理对象，选择哪种方式取决于被代理的目标对象。 -->
    <!-- 1. JDK动态代理：默认情况下，如果目标对象实现了至少一个接口，Spring AOP会使用JDK动态代理。这种方式通过反射机制，在运行时创建了一个实现了目标对象所有接口的代理对象。这要求被代理的类至少实现了一个接口。 -->
    <!-- 2. 如果目标对象没有实现任何接口，Spring AOP会退回到使用CGLIB库生成代理对象。CGLIB（Code Generation Library）是一个第三方代码生成库，通过继承方式实现代理，可以在运行时动态扩展Java类。 -->
    <bean id="dynamicTestService" class="org.springframework.aop.framework.ProxyFactoryBean">
        <!-- 代理的业务对象为上面定义的bean -->
        <property name="target" ref="DynamicTestServiceTarget"/>
        <!-- 定义代理需要实现的接口列表。如果指定了此属性，则代理将是基于Java接口的动态代理。如果没有指定，则会使用CGLIB创建基于类的代理。 -->
        <!-- 明确指出代理应该实现的接口,这意味着代理将对外表现为DynamicTestService接口的实现,客户端代码可以透明地使用它，就像使用实际的服务实现一样，而不必知道代理的存在。-->
        <property name="proxyInterfaces" value="com.hundsun.demo.spring.db.dynamicdb.DynamicTestService"/>
        <!-- 这里通过一个列表指定了一个或多个拦截器的名称，这些拦截器会在调用目标方法前后执行。 -->
        <property name="interceptorNames">
            <list>
                <!-- 这里指定了之前配置好的事务拦截器来管理事务 -->
                <value>transactionInterceptor</value>
            </list>
        </property>
    </bean>
    <!-- 到此,事务管理器,事务拦截器,业务对象实现事务都已经配置完成 -->


    <!-- ##################################################################################### -->
    <!-- ####################################### Mybatis ##################################### -->
    <!-- ##################################################################################### -->
    <!-- 它负责创建SqlSessionFactory，后者是MyBatis中非常重要的一个对象，用于创建SqlSession -->
    <!-- 通过SqlSession，应用程序就可以执行SQL命令、管理事务和处理映射。 -->
    <bean id="sessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <!-- 指定了MyBatis将用于数据库操作的数据源 -->
        <property name="dataSource" ref="dataSource"/>
        <!-- 指定了MyBatis的全局配置文件的位置。这个文件通常包含了MyBatis的配置信息，如类型别名、类型处理器、设置等。通过这个配置，MyBatis知道如何连接数据库以及如何生成SQL语句。 -->
        <property name="configLocation" value="spring-mybatis-config.xml"/>
        <!-- 定义了MyBatis mapper XML文件的位置 -->
        <property name="mapperLocations" value="mapper/*.xml"/>
    </bean>
    <!-- 这个类的作用是自动扫描指定包下的Mapper接口，并为它们创建代理对象，这些代理对象实际上就是执行SQL操作的MyBatis mapper -->
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <!-- 可以指定一个或多个包的路径，框架会扫描这些包下的所有接口 -->
        <property name="basePackage" value="com.hundsun.demo.spring.mybatis.mapper"/>
    </bean>
    <!--
     假设不使用上面的自动扫描
     MapperFactoryBean是Spring提供的一个工厂bean，用于生成Mapper接口的代理实现
    <bean id="exampleMapper" class="org.mybatis.spring.mapper.MapperFactoryBean">
        这是你的Mapper接口的全限定名
        <property name="mapperInterface" value="com.hundsun.demo.spring.mybatis.mapper.ExampleMapper"/>
        引用前面定义的SqlSessionFactoryBean，它是MyBatis中生成SqlSession的工厂，而SqlSession是执行SQL操作的关键。
        <property name="sqlSessionFactory" ref="sqlSessionFactory"/>
    </bean>
    那就需要想这样对于每个mapper都定义一遍
     -->
    <!-- mybatis的配置到此为止 -->


    <!-- ##################################################################################### -->
    <!-- ######################## Mybatis+多数据源+<tx:advice>配置事务 ########################## -->
    <!-- ##################################################################################### -->
    <!-- mybatis 整合进 spring 之后, 事务的管理权就交给了 spring, 所以如果我们要使用事务, 那就必须按规矩办事, 好好的声明 spring 事务吧! -->
    <bean id="mybatisTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <!-- 这里数据源依旧还是使用之前定义的多数据源 -->
        <property name="dataSource" ref="dataSource"/>
    </bean>
    <!-- 启用了对@Transactional注解的支持，这意味着你可以在需要事务管理的方法上使用@Transactional注解 -->
    <!-- <tx:annotation-driven/> -->
    <!-- 定义了一个事务管理策略txAdvice,指明了哪些方法需要进行事务管理，以及事务的具体属性（如传播行为、是否只读、异常回滚条件等） -->
    <tx:advice id="txAdvice" transaction-manager="mybatisTransactionManager">
        <tx:attributes>
            <!-- 任何名为mybatisSpringTransaction的方法将在调用时开启事务，并且这个事务在遇到Exception时会回滚。 -->
            <!-- <tx:method name="mybatisSpringTransaction" propagation="REQUIRED" read-only="false" rollback-for="java.lang.Exception"/> -->
            <tx:method name="mybatisSpringTransaction"/>
            <!-- <tx:method name="*"配置表示匹配所有方法名 -->
            <!-- <tx:method name="*"/> -->
        </tx:attributes>
    </tx:advice>
    <!-- 这里使用面向 aop 的命名空间 -->
    <aop:config>
        <!-- <aop:pointcut>**定义了一个或多个切点，指定了哪些方法（即哪个执行点）应该被增强（如事务管理）。expression属性用于指定这些方法的表达式。 -->
        <!--  -->
        <!-- 单独配置方法时,一定要注意方法参数是否一致 -->
        <!-- <aop:pointcut id="mybatisMethods" expression="execution(* com.hundsun.demo.spring.mybatis.MyBatisDynamicdbService.*(..))"/> -->
        <aop:pointcut id="mybatisMethods"
                      expression="execution(* com.hundsun.demo.spring.mybatis.MyBatisDynamicdbService.mybatisSpringTransaction(..))"/>
        <!-- 通过aop:advisor将前面定义的事务管理策略txAdvice应用到这个切点上，这样就实现了对指定方法的事务管理。 -->
        <aop:advisor advice-ref="txAdvice" pointcut-ref="mybatisMethods"/>
    </aop:config>
    <bean name="myBatisDynamicdbService" class="com.hundsun.demo.spring.mybatis.MyBatisDynamicdbServiceImpl" autowire="byName"/>
    <bean class="com.hundsun.demo.spring.mybatis.MyBatisDynamicdbTestListener">
        <property name="myBatisDynamicdbService" ref="myBatisDynamicdbService"/>
    </bean>


    <!-- ##################################################################################### -->
    <!-- ##################################### SpringDAO ##################################### -->
    <!-- ##################################################################################### -->
    <!-- 配置 UserDAO Bean -->
    <bean id="userDAO" class="com.hundsun.demo.spring.db.springdao.UserDAOImpl">
        <constructor-arg ref="dataSource"/>
    </bean>
    <bean id="userTemplateDAO" class="com.hundsun.demo.spring.db.springdao.UserDAOJdbcTemplateImpl">
        <constructor-arg ref="dataSource"/>
    </bean>

</beans>