<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd
       http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       http://www.springframework.org/schema/mvc/spring-mvc.xsd"

>

    <!-- HandlerMapping, DispatcherServlet 用这个处理器映射来确定请求将给到哪一个 Controller 来处理 -->
    <!-- Spring提供了多种映射器, 在没有配置的情况下, 默认会选择 BeanNameUrlHandlerMapping -->
    <bean id="handlerMapping" class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/>

    <!-- 配置视图解析器, 将控制器方法返回的逻辑视图解析为物理视图, DispatcherServlet 用这个来确定将控制器返回的逻辑视图名称转换成渲染结果的实际视图 -->
    <!-- InternalResourceViewResolver 类用于解析视图名称，并将其解析为内部资源（例如 JSP 文件）的实际路径。 -->
    <bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/jsp/"/>
        <property name="suffix" value=".jsp"/>
    </bean>

    <!-- 当请求被映射到 “/simple” 路径时，Spring MVC 将会调用 SimpleController 中的相应方法来处理请求，并返回名为 “SimpleMVC” 的视图。 -->
    <!-- 配置 controller, 映射为 /simple -->
    <bean name="/simple" class="com.hundsun.demo.spring.mvc.controller.SimpleController">
        <property name="viewName" value="SimpleMVC"/>
    </bean>

    <!-- 基于注解的形式的控制器 -->
    <!-- 配置自动扫描包 -->
    <context:component-scan base-package="com.hundsun.demo.spring"/>


    <!-- 告诉 Spring MVC 框架去扫描应用程序中所有的类，查找带有特定注解（如 @Controller、@RequestMapping 等）的类，并根据这些注解配置相应的请求映射和处理器。 -->
    <!-- 启用了这个配置后，Spring MVC 将会自动注册 DefaultAnnotationHandlerMapping 和 AnnotationMethodHandlerAdapter 这两个处理器，用于处理基于注解的请求映射和方法处理。 -->
    <!-- Spring MVC 类型转换, 数据格式化和数据校验 -->
    <mvc:annotation-driven/>

    <!-- <mvc:resources> 元素用于指定一个或多个静态资源的映射关系，以便让 Spring MVC 框架知道如何处理这些静态资源的请求。 -->
    <!-- mapping="/script/**" 指定了 URL 匹配模式，用于匹配静态资源的请求路径。这里的 "/script/**" 表示匹配以 “/script/” 开头的所有请求路径。 -->
    <!-- location="/script/" 指定了静态资源的存储位置。这里的 "/script/" 是相对于 web 应用程序根目录的路径，用于指定静态资源文件的实际存储位置。 -->
    <!-- 这样配置后，当有请求路径匹配到 "/script/**" 时，Spring MVC 将会在 "/script/" 目录下寻找对应的静态资源文件，并将其返回给客户端。 -->
    <mvc:resources mapping="/scripts/**" location="/scripts/"/>

    <!-- 使用该配置元素后，Spring MVC 将会注册一个 DefaultServletHttpRequestHandler，它会将请求传递给Servlet容器的默认Servlet进行处理。 -->
    <!-- 这个 handler 会对进入 DispatcherServlet 的请求进行筛选, 如果发现是没有经过映射的请求, 会把这个请求交给 Web 服务器默认的 Servlet 处理 -->
    <mvc:default-servlet-handler/>


    <!-- 配置拦截器 -->
    <mvc:interceptors>
        <!-- 这个标签定义了一个拦截器。拦截器可以看作是一个过滤器，它能够在请求到达控制器之前、处理完请求后以及渲染视图之前执行特定的代码。 -->
        <mvc:interceptor>
            <!-- 这里的 <mvc:mapping> 定义了拦截器应用的 URL 模式。path="/**" 表示拦截器将应用于所有的请求路径。这是一个非常广泛的模式，实际上会匹配所有的 URL。 -->
            <mvc:mapping path="/**"/>
            <!--  这里的 <mvc:exclude-mapping> 定义了哪些请求路径不应该被拦截器处理。path="/" 指的是应用的根路径。这意味着，虽然拦截器会拦截所有的请求，但是它不会处理到达应用根路径的请求。这通常用于允许对主页的无障碍访问，而无需经过拦截器的处理。 -->
            <mvc:exclude-mapping path="/"/>
            <bean class="com.hundsun.demo.spring.mvc.filter.SimpleFilter"/>
        </mvc:interceptor>
    </mvc:interceptors>


    <!-- spring相关的配置信息 -->
    <!-- BeanFactoryPostProcessor -->
    <!-- 配置如果实现IgnoreBean接口,那么这个bean的自动注入将不会生效 -->
    <bean class="com.hundsun.demo.spring.init.processor.IgnoreBeanFactoryPostProcessor"/>
    <bean class="com.hundsun.demo.spring.init.processor.IgnoreBean"/>

    <!-- BeanPostProcessor -->
    <!-- <bean class="com.hundsun.demo.spring.init.processor.CustomBeanPostProcessor"/> -->
    <!-- <bean class="com.hundsun.demo.spring.init.processor.PrintMergedBeanDefinitionPostProcessor"/> -->
    <!-- <bean class="com.hundsun.demo.spring.init.processor.PrintInstantiationAwareBeanPostProcessor"/> -->
    <!-- <bean class="com.hundsun.demo.spring.init.processor.PrintSmartInstantiationAwareBeanPostProcessor"/> -->

    <!-- 当注入MySQLService的实现类的时候,全部改成注入MySQLServiceProxy而不是MySQLServiceImpl -->
    <bean class="com.hundsun.demo.spring.init.processor.ResolvableDependencyPostProcessor"/>
    <bean name="mySQLServiceImpl" class="com.hundsun.demo.spring.jdk.pattern.structural.proxy.MySQLServiceImpl"/>
    <bean name="mySQLServiceProxy" class="com.hundsun.demo.spring.jdk.pattern.structural.proxy.normal.MySQLServiceProxy">
        <property name="mySqlService" ref="mySQLServiceImpl"/>
    </bean>

    <!-- spring监听机制,由 ApplicationListener + ApplicationEvent 实现 -->
    <bean class="com.hundsun.demo.spring.init.listener.SimpleListener"/>

    <!-- Spring通过三级缓存来解决循环依赖的问题 -->
    <!-- Q1: 不过三级缓存确实可以解决循环依赖的问题, 但是我无法回答的是为什么要用三级缓存, 因为看上去二级缓存就可以解决问题了, 三级缓存似乎有点多余, 它肯定有更多的用途... 2023-2-10 -->
    <!-- A1: 二级缓存确实可以解决循环依赖的问题, 但是如果我们加入 Spring AOP 的话, 二级缓存就无法解决了, 三级缓存解决了代理对象的注入问题 -->
    <bean name="positiveBean" class="com.hundsun.demo.spring.init.circle.PositiveBean">
        <property name="negativeBean" ref="negativeBean"/>
        <!-- <constructor-arg name="negativeBean" ref="negativeBean"/> -->
        <!-- <lookup-method name="getNegativeBean" bean="negativeBean"/> -->
    </bean>
    <bean name="negativeBean" class="com.hundsun.demo.spring.init.circle.NegativeBean">
        <property name="positiveBean" ref="positiveBean"/>
        <!-- <constructor-arg name="positiveBean" ref="positiveBean"/> -->
    </bean>
    <bean name="circleBean" class="com.hundsun.demo.spring.init.circle.CircleBean">
        <property name="circleBean" ref="circleBean"/>
        <property name="name" value="first"/>
    </bean>

    <!-- ##################################################################################### -->
    <!-- ##################################### Spring AOP #################################### -->
    <!-- ##################################################################################### -->
    <!-- 用于启用 AspectJ 自动代理功能。 -->
    <!-- Spring 将会自动检测并创建应用程序中使用了 AspectJ 注解的 bean，并将其装配为代理对象，以便应用程序中的切面可以对这些对象进行增强。 -->
    <aop:aspectj-autoproxy/>
    <!-- 这是一个AspectJ的bean,如果不开启上面的配置,那么这个类将不会被增强 -->
    <bean class="com.hundsun.demo.commom.core.aop.DoneTimeAspect"/>
    <!-- 用于支持基于注解的 AspectJ 切面编程-->
    <!-- <bean class="org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator"> -->
    <!--     &lt;!&ndash; 配置指示 Spring 使用 CGLIB 来创建代理对象，而不是标准的 Java 接口代理。 &ndash;&gt; -->
    <!--     <property name="proxyTargetClass" value="true"/> -->
    <!-- </bean> -->


    <!-- ##################################################################################### -->
    <!-- ################################### Spring 多数据源 ################################### -->
    <!-- ##################################################################################### -->
    <!-- 先定义三套数据库 -->
    <bean id="masterDataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url"
                  value="jdbc:mysql://192.168.80.128:3306/yiibaidb?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;serverTimezone=Asia/Shanghai"/>
        <property name="username" value="root"/>
        <property name="password" value="123456"/>
    </bean>
    <bean id="secondDataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url"
                  value="jdbc:mysql://192.168.80.128:3306/yiibaidb?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;serverTimezone=Asia/Shanghai"/>
        <property name="username" value="root"/>
        <property name="password" value="123456"/>
    </bean>
    <bean id="thirdDataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url"
                  value="jdbc:mysql://192.168.80.128:3306/yiibaidb?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;serverTimezone=Asia/Shanghai"/>
        <property name="username" value="root"/>
        <property name="password" value="123456"/>
    </bean>
    <!-- 用于切换动态数据源的 AbstractRoutingDataSource -->
    <bean id="dataSource" class="com.hundsun.demo.spring.db.dynamicdb.DynamicDataSource">
        <property name="defaultTargetDataSource" ref="masterDataSource"/>
        <property name="targetDataSources">
            <map key-type="com.hundsun.demo.spring.db.dynamicdb.DynamicDataSourceType">
                <entry key="MASTER" value-ref="masterDataSource"/>
                <entry key="SECOND" value-ref="secondDataSource"/>
                <entry key="THIRD" value-ref="thirdDataSource"/>
            </map>
        </property>
    </bean>
    <!-- 一个注入AbstractRoutingDataSource的JdbcTemplate -->
    <bean id="multipleDataSourceJdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"/>
    </bean>
    <!-- 测试多数据源的监听器 -->
    <bean class="com.hundsun.demo.spring.db.dynamicdb.MultipleDataSourceTestListener">
        <!-- 注入dynamicTestService这个业务对象,声明信息在下面 -->
        <property name="dynamicTestService" ref="dynamicTestService"/>
    </bean>

    <!-- ##################################################################################### -->
    <!-- ####################################### 事务管理 ###################################### -->
    <!-- ##################################################################################### -->
    <!-- 这是一个事务管理器,有一个dataSource的属性,即指定这个事务管理器应该用哪个数据源来管理事务 -->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <!-- 绑定对哪个数据源生效 -->
        <property name="dataSource" ref="dataSource"/>
    </bean>
    <!-- 有了事务管理器还不够,事务管理器需要知道在哪里开启事务才行,并且需要知道事务隔离级别之类的属性,所以有了TransactionInterceptor -->
    <!-- 这个Bean是Spring事务管理的关键，它定义了事务的属性，比如事务的传播行为。-->
    <!-- 这里，它引用了transactionManager（需要在其他地方定义）来管理事务，并且设置了事务属性 -->
    <bean id="transactionInterceptor" class="org.springframework.transaction.interceptor.TransactionInterceptor">
        <!-- 被配置为使用transactionManager这个Bean来管理事务。 -->
        <property name="transactionManager" ref="transactionManager"/>
        <!-- 这部分配置定义了哪些方法应该在事务的环境下执行，以及这些事务应该遵循的规则。 -->
        <property name="transactionAttributes">
            <props>
                <!-- multipleDataSourceTransaction方法是测试多数据源DynamicTestService的一个方法 -->
                <!-- 指定multipleDataSourceTransaction方法（或更可能是一系列方法的模式）需要遵循的事务传播行为为PROPAGATION_REQUIRE -->
                <prop key="multipleDataSourceTransaction">PROPAGATION_REQUIRED</prop>
            </props>
        </property>
    </bean>
    <!-- 事务管理器现在都定义好了,但是业务对象依旧不具备事务特性,我们需要通过生成代理对象来拦截业务对象,使其在业务方法外包裹一层事务逻辑来实现事务 -->
    <!-- 这是一个实际的业务对象 -->
    <bean name="DynamicTestServiceTarget" class="com.hundsun.demo.spring.db.dynamicdb.DynamicTestServiceImpl" autowire="byName"/>
    <!-- ProxyFactoryBean可以用来为目标对象创建一个代理，这个代理可以实现相同的接口或继承相同的类，而且可以在目标方法的调用前后添加额外的处理逻辑，这种技术通常用于事务管理、日志记录、安全控制等方面。 -->
    <!-- Spring AOP默认使用JDK动态代理和CGLIB代理两种方式来生成代理对象，选择哪种方式取决于被代理的目标对象。 -->
    <!-- 1. JDK动态代理：默认情况下，如果目标对象实现了至少一个接口，Spring AOP会使用JDK动态代理。这种方式通过反射机制，在运行时创建了一个实现了目标对象所有接口的代理对象。这要求被代理的类至少实现了一个接口。 -->
    <!-- 2. 如果目标对象没有实现任何接口，Spring AOP会退回到使用CGLIB库生成代理对象。CGLIB（Code Generation Library）是一个第三方代码生成库，通过继承方式实现代理，可以在运行时动态扩展Java类。 -->
    <bean id="dynamicTestService" class="org.springframework.aop.framework.ProxyFactoryBean">
        <!-- 代理的业务对象为上面定义的bean -->
        <property name="target" ref="DynamicTestServiceTarget"/>
        <!-- 定义代理需要实现的接口列表。如果指定了此属性，则代理将是基于Java接口的动态代理。如果没有指定，则会使用CGLIB创建基于类的代理。 -->
        <!-- 明确指出代理应该实现的接口,这意味着代理将对外表现为DynamicTestService接口的实现,客户端代码可以透明地使用它，就像使用实际的服务实现一样，而不必知道代理的存在。-->
        <property name="proxyInterfaces" value="com.hundsun.demo.spring.db.dynamicdb.DynamicTestService"/>
        <!-- 这里通过一个列表指定了一个或多个拦截器的名称，这些拦截器会在调用目标方法前后执行。 -->
        <property name="interceptorNames">
            <list>
                <!-- 这里指定了之前配置好的事务拦截器来管理事务 -->
                <value>transactionInterceptor</value>
            </list>
        </property>
    </bean>
    <!-- 到此,事务管理器,事务拦截器,业务对象实现事务都已经配置完成 -->


    <!-- ##################################################################################### -->
    <!-- ####################################### Mybatis ##################################### -->
    <!-- ##################################################################################### -->
    <!-- 它负责创建SqlSessionFactory，后者是MyBatis中非常重要的一个对象，用于创建SqlSession -->
    <!-- 通过SqlSession，应用程序就可以执行SQL命令、管理事务和处理映射。 -->
    <bean id="sessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <!-- 指定了MyBatis将用于数据库操作的数据源 -->
        <property name="dataSource" ref="dataSource"/>
        <!-- 指定了MyBatis的全局配置文件的位置。这个文件通常包含了MyBatis的配置信息，如类型别名、类型处理器、设置等。通过这个配置，MyBatis知道如何连接数据库以及如何生成SQL语句。 -->
        <property name="configLocation" value="classpath:spring-mybatis-config.xml"/>
        <!-- 定义了MyBatis mapper XML文件的位置 -->
        <property name="mapperLocations" value="classpath:mapper/*.xml"/>
    </bean>
    <!-- 这个类的作用是自动扫描指定包下的Mapper接口，并为它们创建代理对象，这些代理对象实际上就是执行SQL操作的MyBatis mapper -->
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <!-- 可以指定一个或多个包的路径，框架会扫描这些包下的所有接口 -->
        <property name="basePackage" value="com.hundsun.demo.spring.mybatis.mapper"/>
    </bean>
    <!--
     假设不使用上面的自动扫描
     MapperFactoryBean是Spring提供的一个工厂bean，用于生成Mapper接口的代理实现
    <bean id="exampleMapper" class="org.mybatis.spring.mapper.MapperFactoryBean">
        这是你的Mapper接口的全限定名
        <property name="mapperInterface" value="com.hundsun.demo.spring.mybatis.mapper.ExampleMapper"/>
        引用前面定义的SqlSessionFactoryBean，它是MyBatis中生成SqlSession的工厂，而SqlSession是执行SQL操作的关键。
        <property name="sqlSessionFactory" ref="sqlSessionFactory"/>
    </bean>
    那就需要想这样对于每个mapper都定义一遍
     -->
    <!-- mybatis的配置到此为止 -->


    <!-- ##################################################################################### -->
    <!-- ######################## Mybatis+多数据源+<tx:advice>配置事务 ########################## -->
    <!-- ##################################################################################### -->
    <!-- mybatis 整合进 spring 之后, 事务的管理权就交给了 spring, 所以如果我们要使用事务, 那就必须按规矩办事, 好好的声明 spring 事务吧! -->
    <bean id="mybatisTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <!-- 这里数据源依旧还是使用之前定义的多数据源 -->
        <property name="dataSource" ref="dataSource"/>
    </bean>
    <!-- 启用了对@Transactional注解的支持，这意味着你可以在需要事务管理的方法上使用@Transactional注解 -->
    <!-- <tx:annotation-driven/> -->
    <!-- 定义了一个事务管理策略txAdvice,指明了哪些方法需要进行事务管理，以及事务的具体属性（如传播行为、是否只读、异常回滚条件等） -->
    <tx:advice id="txAdvice" transaction-manager="mybatisTransactionManager">
        <tx:attributes>
            <!-- 任何名为mybatisSpringTransaction的方法将在调用时开启事务，并且这个事务在遇到Exception时会回滚。 -->
            <!-- <tx:method name="mybatisSpringTransaction" propagation="REQUIRED" read-only="false" rollback-for="java.lang.Exception"/> -->
            <tx:method name="mybatisSpringTransaction"/>
            <!-- <tx:method name="*"配置表示匹配所有方法名 -->
            <!-- <tx:method name="*"/> -->
        </tx:attributes>
    </tx:advice>
    <!-- 这里使用面向 aop 的命名空间 -->
    <aop:config>
        <!-- <aop:pointcut>**定义了一个或多个切点，指定了哪些方法（即哪个执行点）应该被增强（如事务管理）。expression属性用于指定这些方法的表达式。 -->
        <!--  -->
        <!-- 单独配置方法时,一定要注意方法参数是否一致 -->
        <!-- <aop:pointcut id="mybatisMethods" expression="execution(* com.hundsun.demo.spring.mybatis.MyBatisDynamicdbService.*(..))"/> -->
        <aop:pointcut id="mybatisMethods"
                      expression="execution(* com.hundsun.demo.spring.mybatis.MyBatisDynamicdbService.mybatisSpringTransaction(..))"/>
        <!-- 通过aop:advisor将前面定义的事务管理策略txAdvice应用到这个切点上，这样就实现了对指定方法的事务管理。 -->
        <aop:advisor advice-ref="txAdvice" pointcut-ref="mybatisMethods"/>
    </aop:config>
    <bean name="myBatisDynamicdbService" class="com.hundsun.demo.spring.mybatis.MyBatisDynamicdbServiceImpl" autowire="byName"/>
    <bean class="com.hundsun.demo.spring.mybatis.MyBatisDynamicdbTestListener">
        <property name="myBatisDynamicdbService" ref="myBatisDynamicdbService"/>
    </bean>


    <!-- ##################################################################################### -->
    <!-- ##################################### SpringDAO ##################################### -->
    <!-- ##################################################################################### -->
    <!-- 配置 UserDAO Bean -->
    <bean id="userDAO" class="com.hundsun.demo.spring.mvc.springdao.UserDAOImpl">
        <constructor-arg ref="dataSource"/>
    </bean>
    <bean id="userTemplateDAO" class="com.hundsun.demo.spring.mvc.springdao.UserDAOJdbcTemplate">
        <constructor-arg ref="dataSource"/>
    </bean>

    <!-- 开启注解驱动 -->
    <!-- <context:annotation-config/> -->

    <bean name="simpleService" class="com.hundsun.demo.spring.init.SimpleServiceImpl"/>
    <bean class="com.hundsun.demo.spring.init.listener.SimpleListener"/>

    <!-- Hibernate SessionFactory 配置 -->
    <bean id="hibernateSessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
        <property name="dataSource" ref="dataSource"/>
        <property name="hibernateProperties">
            <props>
                <prop key="hibernate.dialect">org.hibernate.dialect.MySQLDialect</prop>
                <!-- 其他 Hibernate 相关配置 -->
            </props>
        </property>
    </bean>

    <!-- 配置 Hibernate 的事务管理器 -->
    <bean id="hibernateTransactionManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager">
        <property name="sessionFactory" ref="hibernateSessionFactory"/>
    </bean>

    <bean class="org.springframework.orm.hibernate5.HibernateTemplate">
        <constructor-arg name="sessionFactory" ref="hibernateSessionFactory"/>
    </bean>
</beans>