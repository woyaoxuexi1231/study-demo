> 1. review segment ID 生成算法
> 2. 线程池如何保证线程一直运行, 并等待新任务 [worker队列+阻塞循环获取任务]
> 3. 关于迭代器可以在循环时安全的安全的删除元素(不使用迭代器进行操作,是由于对数组本身进行删除会造成跳过元素或者重复处理元素) [next方法每次都会拷贝一次数组再取元素]
> 4. 安全失败(迭代过程中，即使底层的集合被修改了，迭代器仍然可以继续工作且不会抛出 ConcurrentModificationException 异常)[CopyOnWriteArrayList写时复制]和快速失败[ArrayList的modCount]
> 5. TODO HashMap
> 6. 关于String的一些冷知识, String 是一个不可变的类，表示字符序列. 使用双引号 "" 创建字符串时，我们实际上是在直接使用一个字符串字面量
> 7. 数据库碎片整理方案
> 8. TODO main为什么必须是静态的(涉及jvm)
> 9. CopyOnWriteArrayList的原理(写时复制和最终一致性)
> 10. 动态绑定(（也称为晚期绑定或运行时多态性）是一种在运行时（而非编译时）确定要调用方法的对象的机制)
> 11. 工厂模式, 建造者模式, 单例模式(四种实现方式)
> 12. ReentrantLock(基于AbstractQueuedSynchronizer)加锁释放锁过程(源码)
> 13. 实现阻塞队列 [Object对象的wait()和notify()]或者[ArrayBlockingQueue]
> 14. MySQL为什么使用可重复读作为数据库的默认隔离级别? [因为MySQL的可重复读就已经提供了最高级别的隔离, 解决了脏读,不可重复读和幻读]
> 15. MySQL是如何在可重复读级别下解决幻读问题的? [MVCC]
> 16. (实操)Linux 环境下如何查找哪个线程使用 CPU 最长
> 17. TODO 线程调度算法有哪些?
> 18. TODO 哪些情况可能会导致内存泄漏
> 19. Java内存模型和Java的内存分区
> 20. GC的判定方法(引用计数法和可达性分析法(引用链法))
> 21. TODO SafePoint
> 22. TODO GC的三种收集算法
> 23. TODO 有哪些具体的GC收集器
> 24. 类的加载过程
> 25. web->springmvc->springboot前后端分离
> 26. websocket
> 27. 消息重复消费的解决方案
> 28. 消息幂等性(需要业务代码具备这种幂等性操作)
> 29. 消息的有序性(单一消费者模式,kafka分区顺序,RocketMQ顺序消息队列)
> 30. dubbo注册中心宕机,服务是否可用
> 31. 什么是dubbo
> 32. 分布式架构的解析
> 33. dubbo的服务降级(mock)
> 34. dubbo的五种负载均衡策略