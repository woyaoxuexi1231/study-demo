<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd




       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       http://www.springframework.org/schema/mvc/spring-mvc.xsd"
>

    <!-- 引入我们mvc之外的spring上下文配置 -->
    <import resource="applicationContext.xml"/>

    <!-- ##################################################################################### -->
    <!-- ##################################### Spring MVC #################################### -->
    <!-- ##################################################################################### -->
    <!-- 用于启用基于注解的 MVC 功能 -->
    <!-- 1. 启用注解驱动的控制器：允许您在控制器类中使用注解（如 @Controller、@RequestMapping）来处理 HTTP 请求。 -->
    <!-- 2. 启用数据绑定和数据验证：允许您在控制器方法参数中使用注解（如 @RequestParam、@ModelAttribute）进行数据绑定和验证。 -->
    <!-- 3. 启用内容协商：允许 Spring MVC 根据请求头中的 Accept 参数自动选择合适的响应类型（如 JSON、XML）。 -->
    <!-- 4. 启用 HTTP Message Converters：允许 Spring MVC 自动将请求和响应的数据转换为各种格式（如 JSON、XML）。 -->
    <!-- 5. 启用异步支持：允许您在控制器方法中使用异步处理方式来处理 HTTP 请求。 -->
    <!-- 告诉 Spring MVC 框架去扫描应用程序中所有的类，查找带有特定注解（如 @Controller、@RequestMapping 等）的类，并根据这些注解配置相应的请求映射和处理器。 -->
    <!-- 启用了这个配置后，Spring MVC 将会自动注册 DefaultAnnotationHandlerMapping 和 AnnotationMethodHandlerAdapter 这两个处理器，用于处理基于注解的请求映射和方法处理。 -->
    <mvc:annotation-driven/>
    <!-- 这里有个问题是,即使配置了<mvc:annotation-driven/>,也需要配置包扫描,没有注册bean,上面的配置是不生效的 -->
    <!-- 而且还有个问题是,这里不配置的话,即使在applicationContext.xml文件里配置了也不行,controller会扫不到,感觉和web容器与spring容器两个启动顺序有关 -->
    <!-- 所以这里重复扫描了,不过应该没关系 -->
    <context:component-scan base-package="com.hundsun.demo.spring"/>
    <!-- 除了使用注解形式的,也可以直接配置 -->
    <!-- 当请求被映射到 “/simple” 路径时，Spring MVC 将会调用 SimpleController 中的相应方法来处理请求，并返回名为 “SimpleMVC” 的视图。 -->
    <!-- 配置 controller, 映射为 /simple -->
    <bean name="/simple" class="com.hundsun.demo.spring.mvc.controller.SimpleController">
        <property name="viewName" value="SimpleMVC"/>
        <property name="userDAO" ref="userDAO"/>
    </bean>

    <!-- 当您在 Spring MVC 应用程序中使用 BeanNameUrlHandlerMapping 时，您可以通过配置 Spring Bean 的名称来指定 URL 映射。例如，如果您有一个名为 "userController" 的控制器 Bean，那么请求 "/user" 将会被映射到该控制器上。 -->
    <!-- 需要注意的是，BeanNameUrlHandlerMapping 是 Spring MVC 默认的处理器映射器之一。当您没有明确配置其他的处理器映射器时，Spring MVC 将会使用 BeanNameUrlHandlerMapping 来处理请求的映射。 -->
    <bean id="handlerMapping" class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/>

    <!-- InternalResourceViewResolver 是 Spring MVC 中的一个视图解析器（View Resolver），用于解析逻辑视图名称并将其解析为实际的视图对象。具体来说，InternalResourceViewResolver 是用于解析基于 JSP 的视图的视图解析器。 -->
    <!-- 在 Spring MVC 中，控制器方法通常返回逻辑视图名称，而不是直接返回视图对象。逻辑视图名称是一个字符串，表示要显示的视图的名称。例如，"home" 可能表示应用程序中的主页视图。 -->
    <!-- InternalResourceViewResolver 负责将这些逻辑视图名称解析为实际的视图对象，它通常用于解析基于 JSP 的视图。例如，如果逻辑视图名称为 "home"，那么 InternalResourceViewResolver 将会解析为相对于某个特定的 JSP 文件的视图对象，以显示主页内容。 -->
    <!-- 在这个示例中，我们配置了一个 InternalResourceViewResolver，并设置了 prefix 和 suffix 属性。prefix 属性指定了 JSP 文件的前缀路径，通常是存放 JSP 文件的目录路径；suffix 属性指定了 JSP 文件的后缀名。 -->
    <!-- 通过这样的配置，当控制器方法返回逻辑视图名称时，InternalResourceViewResolver 将会根据这些配置解析逻辑视图名称为相应的 JSP 视图对象。例如，如果逻辑视图名称为 "home"，那么 InternalResourceViewResolver 将会将其解析为 "/WEB-INF/views/home.jsp" 对应的 JSP 视图。 -->
    <bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/jsp/"/>
        <property name="suffix" value=".jsp"/>
    </bean>

    <!-- <mvc:resources> 是 Spring MVC 中用于处理静态资源的配置元素之一。具体来说，<mvc:resources> 元素用于配置静态资源的映射，使得这些静态资源可以被 Spring MVC 框架直接访问，而无需经过控制器的处理。 -->
    <!-- mapping="/scripts/**"：指定了 URL 路径的模式，即所有以 "/scripts/" 开头的 URL 请求都会被映射到静态资源处理器中进行处理。 -->
    <!-- location="/scripts/"：指定了静态资源的位置，即指定了静态资源存放的路径。在这个例子中，静态资源位于应用程序的根目录下的 "scripts" 目录中。 -->
    <!-- 综合起来，这个配置的含义是：当有请求的 URL 路径以 "/scripts/" 开头时，Spring MVC 框架会去指定的位置（即 "/scripts/" 目录）寻找对应的静态资源，并将其返回给客户端，而不会经过控制器的处理。 -->
    <mvc:resources mapping="/scripts/**" location="/scripts/"/>

    <!-- <mvc:default-servlet-handler/> 是 Spring MVC 中用于处理静态资源的配置元素之一。它的作用是将静态资源的请求转发给 Servlet 容器的默认处理器，通常是 DefaultServlet。 -->
    <!-- 当您在 Spring MVC 应用程序中使用 <mvc:default-servlet-handler/> 时，它会告诉 Spring MVC 框架将静态资源的请求交给 Servlet 容器的默认处理器进行处理，而不会通过 Spring MVC 的 DispatcherServlet 进行处理。 -->
    <!-- 默认情况下，Spring MVC 的 DispatcherServlet 不会处理静态资源的请求，因为它将会尝试匹配控制器来处理这些请求，这可能会导致不必要的性能开销。因此，将静态资源的请求交给 Servlet 容器的默认处理器来处理是一种更有效的方式。 -->
    <!-- 使用 <mvc:default-servlet-handler/> 配置元素可以让您在 Spring MVC 应用程序中更方便地处理静态资源，而无需手动配置特定的处理器映射器或控制器来处理这些请求。 -->
    <mvc:default-servlet-handler/>

    <!-- 拦截器类似于过滤器，它可以在请求到达控制器之前、处理完请求后以及渲染视图之前执行特定的代码，允许您在处理请求的不同阶段添加自定义逻辑。 -->
    <!-- 用于配置拦截器。您可以在其中定义一个或多个拦截器。 -->
    <mvc:interceptors>
        <!-- 这个标签定义了一个拦截器。在这个示例中，我们定义了一个拦截器，将应用于所有的请求路径。 -->
        <mvc:interceptor>
            <!-- 这里的 <mvc:mapping> 元素定义了拦截器应用的 URL 模式。path="/**" 表示拦截器将应用于所有的请求路径，即拦截所有的请求。这是一个非常广泛的模式，实际上会匹配所有的 URL。 -->
            <mvc:mapping path="/**"/>
            <!-- 这个元素定义了哪些请求路径不应该被拦截器处理。path="/" 指的是应用的根路径。这意味着，虽然拦截器会拦截所有的请求，但是它不会处理到达应用根路径的请求。通常用于允许对主页的无障碍访问，而无需经过拦截器的处理。 -->
            <mvc:exclude-mapping path="/"/>
            <!-- 在拦截器配置中，您需要指定要应用的拦截器类。在这个示例中，我们使用 <bean> 元素指定了一个名为 SimpleFilter 的自定义拦截器类。 -->
            <bean class="com.hundsun.demo.spring.mvc.filter.SimpleFilter"/>
        </mvc:interceptor>
    </mvc:interceptors>

</beans>