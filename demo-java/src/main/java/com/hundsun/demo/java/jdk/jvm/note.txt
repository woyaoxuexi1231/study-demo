1. 当点击main方法之后, jvm将进行如下操作
    加载-> (验证->准备->解析) ->初始化->使用->卸载

在加载main方法所在的类时，JVM会尝试解析该类的字节码并发现main方法的调用路径，进而找到main方法内部所引用的其他类。
这个过程就是所谓的“类加载的链接”阶段，它会扫描和解析main方法内部直接或间接引用的其他类，然后逐个加载这些类。
当加载了main方法所在的类后，JVM会递归地加载main方法内部使用到的其他类，以确保在执行main方法时，所有相关的类都已经加载和初始化。
这样做是为了在程序运行时提供所需的类和资源，保证程序的正常执行。
总的来说，JVM会在加载main方法所在的类的过程中，扫描和加载所有main方法内部直接或间接引用的类，以确保程序在执行过程中能够正常运行并访问所有需要的类和资源。

todo 抛出一个问题, 就是为什么 main方法 必须以 public 和 static 修饰

当 JVM 启动时，并不会立即创建 Java 对象的实例。这是因为 JVM 在启动时需要完成一系列的初始化工作，包括但不限于加载类文件、进行类的解析、准备和初始化线程、创建堆内存和栈内存等。这些初始化工作是必要的，以便为 Java 程序的正常执行和内存分配做好准备。
确实可以在JVM启动时实例化main方法所在的类。在实际的JVM实现中，某些情况下会为main方法所在的类创建一个实例，但这不是必须的。这个决定通常取决于JVM的具体实现和设计。
在Java中，main方法作为程序的入口点，它是一个静态方法，因此不需要实例化类来调用它。JVM可以直接加载并执行main方法，而无需实例化它所在的类。这样做有以下几个原因：
方便和规范化：Java规范将main方法定义为静态方法，并规定了它的输入参数和返回类型。这样做是为了方便程序的启动和执行，同时使得程序的入口点易于识别和使用。
节省内存开销：在JVM启动时，预先创建类的实例可能会占用额外的内存空间。考虑到大多数Java程序都不需要在启动时立即创建实例，JVM通常遵循延迟加载的原则，只在需要时才实例化类。
虽然确实可以在JVM启动时就实例化main方法所在的类，但这种设计并不是必须的，也不符合Java规范和惯例。JVM的设计目标是为了提供一个通用的运行环境，能够适应各种Java程序的需求。在实例化类之前，JVM需要进行一系列的准备工作，包括类的加载、内存分配、线程初始化等，这些步骤对于整个Java程序的正常执行是必要的。因此，JVM通常会在初始化阶段完成这些工作，然后再根据需要创建相应的对象实例。

上诉答案没让我信服


