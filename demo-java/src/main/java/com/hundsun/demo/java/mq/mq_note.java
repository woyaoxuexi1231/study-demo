package com.hundsun.demo.java.mq;

/**
 * @projectName: study-demo
 * @package: com.hundsun.demo.spring.mq
 * @className: MessageQueueTest
 * @description: 消息队列学习笔记
 * @author: h1123
 * @createDate: 2023/2/26 16:33
 */

public class mq_note {

    /*
    系统间通信技术
        集群 - 同一个业务被部署在多台服务器上
        分布式 - 同一个业务被拆分成多个子业务部署在不同的服务器上
        微服务 - 相比分布式粒度更小, 可以说是把一个子业务继续拆分成不同的部分, 每一个部分是一个微服务, 微服务不一定要部署在不同的服务器上, 多个微服务可以部署在同一个机器上

        目前通常有两种系统间通信的方式 - 基础远程过程调用的方式(RPC), 基于消息队列的方式
            RPC 是一种通过网络从远程计算机程序上请求服务, 而不需要了解底层网络技术的协议
                1. RPC 本身它是一种通信协议, Dubbo, Thrift, GRPC 都是用 RPC
                2. 网络通信的实现是透明的, 调用方不需要关心网络之间的通信协议, 网络 I/O 模型, 通信的信息格式等
                3. 跨语言, 调用方实际上并不清楚对端服务器使用的是什么程序语言, 对于调用方来说, 无论其使用的是何种程序语言, 调用都应该成功
            基于消息队列的方式是指由应用中的某个系统负责发送信息, 由关心这条消息的相应系统负责接受消息, 并在收到消息后进行各个系统内的业务处理
    1. 为什么要使用消息队列?
        异步处理, 解耦, 流量削峰, 日志收集, 事务一致性

    2. 消息队列的功能特点
        Broker - 消息处理中心, 负责消息的接收, 存储, 转发
        Producer - 消息生产者, 负责产生和发送消息到消息处理中心
        Consumer - 消息消费者, 负责从消息处理中心获取消息, 并进行相应的处理

        1. 消息堆积 - 某个时间段消费者处理消息的速度跟不上生产者发送消息的速度, 就会导致消息的逐渐积压而得不到释放
        2. 消息持久化 - 为了达到流量削峰等目的, 消息处理中心不应该直接把消息发给消费者, 将消息暂存下来, 在合适的时机发给消费者才是消息处理中心应该做的事情, 所以为了不让存下来的消息丢失, 势必要将消息持久化
        3. 可靠投递 - 不允许消息丢失的情况发生
        4. 消息重复 - 有些消息队列为了支持消息的可靠投递, 会选择先将消息持久化, 然后在不确定消息是否发送成功或发送失败时不停的轮询这些消息去发送给消费者, 保证消息的不会丢失, 这也带来的消息的重复消费问题
        5. 严格有序 - 在实际的业务场景中, 有些情景需要按生产消息时的顺序来消费消息
        6. 集群 - 实现高可用性, 排除单点故障引起的服务中断, 这时候需要消息队列产品提供以集群的模式的支持
        7. 消息中间件 - 非底层操作软件, 非业务应用软件, 不是直接给最终用户使用的, 不能直接给客户带来价值的软件统称为中间件, 消息中间件只关注消息的发送和接受, 利用高效, 可靠的异步消息传递机制集成分布式系统

    3. 消息协议
        开放式协议 - AMQP, MQTT, STOMP, XMPP等, Redis, kafka, zeroMQ是根据自身需要为严格遵循 MQ规范, 而是基于 TCP/IP 自行封装了一套协议

        1. AMQP
            主要概念
                Message - 消息服务器所处理数据的原子单元
                Publisher - 消息的生产者, 是一个向交换器发布消息的客户端应用程序
                Exchange - 交换机, 用来接受消息生产者所发送的消息, 并将这些消息路由给服务器中的队列
                Binding - 用于消息队列和交换器之间的关联, 一个绑定就是基于路由键将交换机和消息队列连接起来的路由规则, 所以可以将交换机理解成一个由绑定构成的路由表
                Virtual Host - 它是消息队列以及相关对象的集合, 是共享同一个身份验证和加密环境的独立服务器域. 每个虚拟主机本质上都是一个 mini 版的消息服务器, 拥有自己的消息队列, 交换机, 绑定和权限机制
                Broker - 消息代理, 表示消息队列的服务器实体, 接受客户端连接, 实现 AMQP 消息队列和路由功能的过程
                Routing Key - 路由规则, 虚拟机可以用它来去顶如何路由一个特定的消息
                Queue - 消息队列, 用来保存消息直接发送给消费者. 它是消息的容器, 也是消息的终点, 一个消息可被投入一个或者多个队列中, 消息一直在队列里面, 等待消费者连接到这个队列将其取走
                Connection - 连接, 可以理解成客户端和消息队列服务器之间的一个 TCP 连接
                Channel - 信道, 仅仅当创建了连接后, 若客户端还是不能发送消息, 则需要为连接创建一个信道, 信道是一条独立的双向数据流通道, 它是建立在真实的 TCP 连接内的虚拟连接, AMQP 命令都是通过信道发出去的
                Consumer - 消息消费者, 表示一个从消息队列中去的消息的客户端应用程序
            核心组件的生命周期
                消息的生命周期 : Publisher -> Broker -> Exchange -> Routing Key -> Queue -> Consumer
                交换器的生命周期 : 每台 AMQP 服务器都预先创建了许多交换器实例, 它们在服务器启动时就存在并且不能被销毁
                队列的生命周期 : 持久化消息队列可以被多个消费者共享, 不管是否有消费者接受, 它们都可以独立存在. 临时消息队列对某个消费者是私有的, 只能绑定到此消费者, 当消费者断开连接时, 该消息队列被删除
            功能命令
                0-9版本中分为功能层和传输层
                0-10版本中分为模型层, 会话层和传输层
            消息数据格式
                所有的消息必须有特定的格式来支持, 这部分就是在传输层中定义的
    4. RabbitMQ
        由 Erlang 语言开发的基于 AMQP 标准的开源实现
        1. AMQP中的消息路由 - 生产者把消息发布到 Exchange 上, Binding 决定交换机上的消息最终被发送到哪个队列
        2. 交换机类型 - 目前由四种类型的交换机
            Direct - 如果消息中的路由键(Routing Key)和 Binding中绑定键(binding key)一致, 交换机就把消息发送到对应的队列中
            Fanout - 不处理路由键, 只是简单的把队列绑定到交换机, 发送到交换机的每条消息都会被转发到与该交换机绑定的所有队列中, 此交换机转发消息是最快的
            Topic - 通过模式匹配分配消息的路由键属性

     */
}
