package com.hundsun.demo.java.jdk;

/**
 * @projectName: study-demo
 * @package: com.hundsun.demo.java.jdk
 * @className: ClassLoaderTest
 * @description:
 * @author: h1123
 * @createDate: 2023/2/24 19:46
 */

public class ClassLoaderTest {

    /*
    虚拟机类加载机制

    1) 类加载的时机
    一个类被加载到虚拟机内存中开始, 到卸载出内存为止, 一共会经历七个阶段 : 加载 -> (验证 -> 准备 ->　解析) -> 初始化 -> 使用 -> 卸载
    其中 加载,验证,准备,初始化,卸载 这五个阶段的顺序是确定的, 而解析则不一定, 在某些情况下, 它可以在初始化阶段之后再开始 // todo

    加载阶段并没有强制规定, 可以由具体的虚拟机决定在什么情况下进行
    对于初始化阶段: 有六种情况必须立刻对类进行初始化
        1. 遇到 new, getstatic, putstatic, invokestatic 四条字节码指令的时候, 如果类型没有进行初始化, 则需要触发其初始化阶段
            使用 new 关键字创建一个对象的实例
            读取或设置一个类型的静态字段(非常量, 常量不会初始化, 会直接在常量池获取这个值)
            调用一个类型的静态方法
        2. 对类型进行反射的时候, 如果类型没有进行过初始化, 则需要先触发其初始化
        3. 当初始化类的时候, 如果发现其父类没有进行过初始化, 那么会先触发其父类的初始化
        4. 当虚拟机启动的时候, 用户需要指定一个要执行的类, 虚拟机会先初始化这个类
        5. 当使用 jdk7 新加入的动态语言支持的时候 // todo
        6. 当一个接口中定义了 jdk8 新加入的默认方法(被 default 修饰的接口方法)时, 如果有这个接口的实现类发生了初始化, 那么该接口要在其之前初始化
        除了以上六种, 那么其他的场景, 都不会触发初始化, 称为被动引用
        典型的
        1. 通过子类引用父类的静态字段, 不会导致子类初始化
        2. 通过数组来引用类, 不会触发类的初始化
        3. 常量在编译阶段会存入调用类的常量池, 本质上没有直接引用到定义常量的类, 因此不会触发这个类的初始化

    2) 类加载的过程
        1. 加载
            加载阶段虚拟机需要完成三件事
                a. 获取这个类的二进制流
                b. 字节流转换成运行时数据结构
                c. 在内存中生成一个 class 对象, 作为方法区的这个类的数据访问入口
            Java虚拟机规范没有规定我们需要从哪里获取这个类的二进制流, 促使我们可以采用多种方式来加载类, 典型的有 jar包获取, 动态代理类
            对于数组来说, 数组类本身不通过类加载器创建, 它是由 Java 虚拟机直接在内存中动态构造出来的, 但是数组类的元素类型(Element Type)最终还是需要类加载器来完成加载 // todo
        2. 验证
            这一阶段的目的是确保 class 文件的字节流中包含的信息符合 Java虚拟机规范 的全部约束要求, 保证这些信息被当作代码运行后不会危害虚拟机自身的安全
            这个阶段大致分为四个阶段的检验动作:
                1. 文件格式检验 - 主要验证字节流是否符合 class 文件格式的规范
                2. 元数据检验 - 主要验证其描述的信息是否符合 Java语言规范
                3. 字节码检验 - 主要目的是确定语义是合法的, 符合逻辑的, 这个阶段需要保证被验证的类的方法在运行的时候不会做出危害虚拟机安全的行为
                4. 符号引用检验 - 主要对类自身以外的各类信息进行匹配性校验 - 这个校验行为发生在连接的第三阶段(解析)
        3. 准备
            该阶段正式为类中定义的变量(被 static 关键字修饰的变量)分配内存并设置类变量的初始值的阶段
            而在这个阶段, 进行内存分配的仅仅只有类变量(静态变量), 没有实例变量
            如果类变量没有被 final 修饰, 那么在这个阶段只会被赋零值, 相对应的是 boolean 类型为 false, int 类型为 0, 如果被 final 修饰, 在这个阶段就会被赋值
        4. 解析
            Java虚拟机将常量池内的符号引用替换为直接引用的过程
            1. 类或接口的解析
            2. 字段的解析
            3. 方法解析 // todo
            4. 接口方法 // todo
        5. 初始化
            类加载过程的最后一个阶段
            初始化阶段会把准备阶段赋零值的变量赋程序编码给定的值
            初始化阶段就是执行类构造器<clinit>()方法的过程
                a. <clinit>()由所有类变量的赋值动作和所有静态代码块中的语句合并而成, 顺序由源文件定义的顺序决定, 静态代码块只能访问到定义在它之前的变量, 定义在它之后的变量, 静态代码块可以赋值但是不能访问
                b. Java虚拟机会保证在子类的 <clinit>() 方法执行前, 父类的  <clinit>() 方法已经被执行了, 这意味着 Object 的  <clinit>() 方法是第一个被执行的  <clinit>()
                c. 父类的静态代码块会先于子类的赋值操作
                d. <clinit>() 方法并不是必须的, 如果没有静态代码块和静态变量的赋值操作, 可以没有 <clinit>()
                e. 接口中不能有静态代码块, 但可以有变量的赋值操作, 也就意味着接口也可以有 <clinit>() 方法, 但是对于接口来说, 执行子类的 <clinit>() 并不会先执行父接口的 <clinit>(), 因为只有父接口定义的变量被访问的时候才会执行 <clinit>(), 因此接口的实现类被初始化的时候也不会去调用接口的 <clinit>()
                f. Java虚拟机必须保证多线程下, 一个类的 <clinit>() 方法能被正确的加锁同步, 如果多个线程同时初始化一个类, 那么只会有一个线程去执行这个类的 <clinit>() 方法, 其他线程阻塞
    3) 类加载器
        通过一个类的全限定类名来获取描述该类的二进制字节流的加载器
        对于任何一个类, 都必须和加载它的类加载器一起共同确立其在 Java 虚拟机中的唯一性

     */
}
