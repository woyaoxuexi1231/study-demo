<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="org.hulei.commom.core.mapper.EmployeeMapperPlus">
    <!-- 缓存设置,开启此标签后配合开启二级缓存的配置,此mapper将开启二级缓存 -->
    <!-- <cache/> -->
    <!-- 引用其他命名空间的缓存 -->
    <!-- <cache-ref namespace="xxx"/> -->

    <!-- 描述如何从数据库的结果集中加载对象-->
    <!-- id:当前的映射关系的命名空间 type:映射到的类的全限定类名 autoMapping: 自动将查询结果集映射到Java对象的属性值,这个值默认是开启的 -->
    <resultMap id="BaseResultMap" type="org.hulei.commom.core.model.pojo.EmployeeDO" autoMapping="false">
        <!-- id列被标识为对象的主键 -->
        <!-- column:数据库中的列名, jdbcType: jdbc的类型, property: 映射到列结果的字段或者属性名,也就是Pojo中的属性名 javaType:属性的类型,通常mybatis可以自己推断-->
        <id column="employeeNumber" jdbcType="BIGINT" property="employeeNumber"/>
        <result column="lastName" jdbcType="VARCHAR" property="lastName"/>
        <result column="firstName" jdbcType="VARCHAR" property="firstName"/>
        <result column="extension" jdbcType="VARCHAR" property="extension"/>
        <result column="email" jdbcType="VARCHAR" property="email"/>
        <result column="officeCode" jdbcType="VARCHAR" property="officeCode"/>
        <result column="reportsTo" jdbcType="INTEGER" property="reportsTo"/>
        <result column="jobTitle" jdbcType="VARCHAR" property="jobTitle"/>
        <result column="last_update_time" jdbcType="TIMESTAMP" property="lastUpdateTime"/>
    </resultMap>

    <!-- sql可以定义宠用的sql代码段 -->
    <sql id="Base_Column_List">
        <!--@mbg.generated-->
        employeeNumber,
        lastName,
        firstName,
        extension,
        email,
        officeCode,
        reportsTo,
        jobTitle,
        last_update_time
    </sql>

    <!-- 对于使用id和result来说必须要对象有属性对应的set方法,对于一些不可变类来说,可能只有构造方法而没有set方法 -->
    <!-- 使用 constructor 就可以直接调用构造方法来构造对象-->
    <!-- 我这里始终不行 -->
    <!--     <resultMap id="consturctMap" type="model.org.hulei.commom.core.EmployeeDO">
            <constructor>
                &lt;!&ndash; column:数据库中的列名, jdbcType: jdbc的类型, name: 映射到列结果的字段或者属性名,也就是Pojo中的属性名 javaType:属性的类型,通常mybatis可以自己推断&ndash;&gt;
                &lt;!&ndash; select:用于加载复杂类型属性的映射语句ID,他会从column属性中指定的列检索数据,作为参数传递给此 select 语句&ndash;&gt;
                <idArg column="employeeNumber" jdbcType="BIGINT" name="employeeNumber" javaType="long"/>
                <arg column="lastName" jdbcType="VARCHAR" name="lastName" javaType="string"/>
                <arg column="firstName" jdbcType="VARCHAR" name="firstName" javaType="string"/>
                <arg column="extension" jdbcType="VARCHAR" name="extension" javaType="string"/>
                <arg column="email" jdbcType="VARCHAR" name="email" javaType="string"/>
                <arg column="officeCode" jdbcType="VARCHAR" name="officeCode" javaType="string"/>
                <arg column="reportsTo" jdbcType="INTEGER" name="reportsTo" javaType="string"/>
                <arg column="jobTitle" jdbcType="VARCHAR" name="jobTitle" javaType="string"/>
                <arg column="last_update_time" jdbcType="TIMESTAMP" name="lastUpdateTime" javaType="date"/>
            </constructor>
        </resultMap> -->

    <resultMap id="employeeWithCustomCollection" type="org.hulei.commom.core.model.EmployeeWithCustomersRsp"
               extends="BaseResultMap">
        <!-- collection标签包含大量的子标签
        property:标明当前的collection对应类中的属性名
        column:指定传递给嵌套查询或者作为条件的一部分的列名,不适用嵌套查询的方式这个参数没用
        javaType:指定集合的类型, List, Set
        ofType:指定集合中的元素的类型
        select:指定一个子查询
        notNullColumn:指定一个列名,只有当该列不为空时,才执行嵌套 . 我这里使用嵌套查询,这个参数没有作用;使用嵌套结果的形式进行查询,这个参数是起作用的
        coloumPrefix:指定一个前缀,用于在嵌套查询中引用列明的时候添加前缀
        resultSet:指定结果集的名字,当使用多个结果集的时候,可以通过这个来区分不同的结果集

        不常用:
        jdbcType:指定jdbc类型,对于这里这种复杂类型似乎没有用处
        typeHander:指定一个自定义的类型转换器,类型转换器可以用于定制我们想要的类型转换,一般默认提供的已经够用了
        foreignColumn:指定外键列明,用于关联主表和子表,通常用于多表联查,如果两张表有明确的外键关联关系,那么这个参数会起作用,这个就不考虑了
        autoMapping:控制是否启动自动映射,默认开启,mybatis会尝试自动映射所有未明确指定的字段
        fetchType:控制是否进行延迟加载,延迟加载可以在需要时才加载相关数据
         -->
        <collection property="customers"
                    javaType="java.util.List"
                    ofType="org.hulei.commom.core.model.pojo.CustomerDO"
                    autoMapping="true"
        >
        </collection>
    </resultMap>

    <resultMap id="employessTreeMap" type="org.hulei.commom.core.model.EmployeeTreeRsp" extends="BaseResultMap">
        <collection
                property="children"
                javaType="java.util.List"
                ofType="org.hulei.commom.core.model.EmployeeTreeRsp"
                column="employeeNumber"
                select="getEmployeeByReportNumber"
        >
        </collection>
    </resultMap>

    <select
            id="getEmployeeWithResultMap"
            resultMap="BaseResultMap"
            useCache="true"
    >
        select e.employeeNumber,
               e.lastName,
               e.firstName,
               e.extension,
               e.email,
               e.officeCode,
               e.reportsTo,
               e.jobTitle,
               e.last_update_time
        from employees e
    </select>

    <select id="getEmployeeByIdTestInject" resultMap="BaseResultMap">
        <!-- 使用#作为占位符, myabtis会创建一个预编译的SQL语句, 把我们实际的参数解析为一个普通的字符串,即使是遇到一些特殊的字符也会被转义, 这有效的防止了 SQL的注入-->
        select *
        from employees
        where employeeNumber = #{employeeId};
        <!--如果使用$作为占位符,由于没有任何的转移操作和处理,所以如果传入的值有恶意的sql,会直接改变原本sql的逻辑,导致安全风险-->
    </select>

    <select id="getEmployeeWithCustomers" resultMap="employeeWithCustomCollection">
        select e.employeeNumber,
               e.lastName,
               e.firstName,
               e.extension,
               e.email,
               e.officeCode,
               e.reportsTo,
               e.jobTitle,
               e.last_update_time,
               c.customerNumber,
               c.customerName,
               c.contactLastName,
               c.contactFirstName,
               c.phone,
               c.addressLine1,
               c.addressLine2,
               c.city,
               c.state,
               c.postalCode,
               c.country,
               c.salesRepEmployeeNumber,
               c.creditLimit
        from employees e
                 left join customers c on e.employeeNumber = c.salesRepEmployeeNumber
        <!--Where标签的好处就是会帮我们移除语句开头的and或者or关键字,避免sql出错,也能避免在没有条件的情况下不输出where-->
        <where>
            <if test="employeeNumber != null">
                employeeNumber = #{employeeNumber}
            </if>
        </where>
    </select>

    <select id="getEmployeeTree" resultMap="employessTreeMap">
        select e.employeeNumber,
               e.lastName,
               e.firstName,
               e.extension,
               e.email,
               e.officeCode,
               e.reportsTo,
               e.jobTitle,
               e.last_update_time
        from employees e
        where e.employeeNumber = #{employeeNumber}
    </select>

    <select id="getEmployeeByReportNumber" resultMap="employessTreeMap">
        select e.employeeNumber,
               e.lastName,
               e.firstName,
               e.extension,
               e.email,
               e.officeCode,
               e.reportsTo,
               e.jobTitle,
               e.last_update_time
        from employees e
        where e.reportsTo = #{reportsTo}
    </select>

    <!-- 以select为例子, 内部标签也是非常多的

     id,命名空间中唯一的标识符
     parameterType,指定传入这条语句的参数的全限定类名,这是一个非必填参数,mybatis会根据类型处理器自动推断传入的类型,而且多个入参也不好指定
     resultType,指定返回结果集的类型, 注意:如果返回结果是集合,那么应该填写集合包含的类型,而不是集合本身的类型
     resultMap,引用的映射结果集的唯一标识符,这个参数与resultType只会同时使用一个,resultMap存在的情况下不会使用resultType,

     fetchSize,给驱动一个建议值,尝试让驱动每次批量返回的结果行数等于这个设置值,默认依赖于数据库驱动, 主要作用于游标查询和流式查询
     resultSetType:指定结果集类型,jdbc相同的配置, FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE


     未找到怎么使用:
     databaseId:配置数据库厂商标识
     resultOrdered:仅针对嵌套结果的select语句,如果为true,将会假设包含了嵌套结果集或者是分组,当返回一个主结果行时就不会产生对前面结果集的引用
     resultSets:这个设置仅适用于多结果集的情况,他将列出语句执行后返回的结果集并赋予每个结果集一个名称,多个名称之间用逗号分隔


     一般不管:
     useCache,如果为true:会导致这条语句的结果被二级缓存缓存起来,默认是false 所有二级缓存有关的开关,最终都必须在总开关打开的情况下才会有效
     flashCache,如果为true:只要语句被调用都会本地缓存和二级缓存失效,这个参数默认是false
     timeout,在抛出异常之前,等待数据库返回请求结果的秒数,默认依赖于数据库驱动
     statementType,标记使用什么对象操作sql语句,可选 STATEMENT，PREPARED 或 CALLABLE. statement:直接操作sql,没有任何预编译;prepared:预处理(preparedStatement),这是默认值;Callable:执行存储过程
     -->
    <!-- select标签的内部子标签测试 -->
    <select id="selectTagsTest"
            resultMap="BaseResultMap">
        select
        <include refid="Base_Column_List">
        </include>
        from employees
    </select>

    <select id="mybatisStreamQuery" resultType="org.hulei.commom.core.model.pojo.EmployeeDO" fetchSize="-2147483648">
        select *
        from employees
    </select>

    <select id="resultSetOpe" resultType="org.hulei.commom.core.model.pojo.EmployeeDO" resultSetType="FORWARD_ONLY">
        select *
        from employees
    </select>
</mapper>