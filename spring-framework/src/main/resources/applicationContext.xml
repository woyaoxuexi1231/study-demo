<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd
       http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd"
>

    <!-- spring的核心就是一个容器: spring应用程序上下文(ApplicationContext), 上下文通过DI(依赖注入)的模式把各种bean连接在一起 -->
    <!-- 除了核心容器外, spring还提供 Web框架, 各种数据持久性选项, 安全框架与其他系统的集成, 运行时监视, 微服务支持, 响应式变成模式 -->

    <!--  -->
    <context:component-scan base-package="org.hulei.spring.xml"/>

    <!--  -->
    <bean class="org.hulei.spring.xml.init.PrototypeBean" scope="prototype"/>


    <!-- spring相关的配置信息 -->
    <!-- BeanFactoryPostProcessor -->
    <!-- 配置如果实现IgnoreBean接口,那么这个bean的自动注入将不会生效 -->
    <bean class="org.hulei.spring.xml.init.processor.MyBeanFactoryPostProcessor"/>
    <bean class="org.hulei.spring.xml.init.processor.IgnoreBean"/>

    <!-- spring监听机制,由 ApplicationListener + ApplicationEvent 实现 -->
    <bean class="org.hulei.spring.xml.init.listener.SimpleListener"/>

    <!-- Spring通过三级缓存来解决循环依赖的问题 -->
    <!-- Q1: 不过三级缓存确实可以解决循环依赖的问题, 但是我无法回答的是为什么要用三级缓存, 因为看上去二级缓存就可以解决问题了, 三级缓存似乎有点多余, 它肯定有更多的用途... 2023-2-10 -->
    <!-- A1: 二级缓存确实可以解决循环依赖的问题, 但是如果我们加入 Spring AOP 的话, 二级缓存就无法解决了, 三级缓存解决了代理对象的注入问题 -->
    <bean name="positiveBean" class="org.hulei.spring.xml.init.circle.PositiveBean">
        <property name="negativeBean" ref="negativeBean"/>
        <!-- <constructor-arg name="negativeBean" ref="negativeBean"/> -->
        <!-- <lookup-method name="getNegativeBean" bean="negativeBean"/> -->
    </bean>
    <bean name="negativeBean" class="org.hulei.spring.xml.init.circle.NegativeBean">
        <property name="positiveBean" ref="positiveBean"/>
        <!-- <constructor-arg name="positiveBean" ref="positiveBean"/> -->
    </bean>
    <bean name="circleBean" class="org.hulei.spring.xml.init.circle.CircleBean">
        <property name="circleBean" ref="circleBean"/>
        <property name="name" value="first"/>
    </bean>


    <!-- ##################################################################################### -->
    <!-- ##################################### Spring AOP #################################### -->
    <!-- ##################################################################################### -->
    <bean class="org.hulei.spring.xml.aop.xml.PrintService"/>
    <!-- 配置切面 -->
    <!-- 当我在LoggingAdvice这个类里声明print方法时,并且想用LoggingAdvice去切它自己,我发现好像办不到.切面会不生效 -->
    <bean id="loggingAdvice" class="org.hulei.spring.xml.aop.xml.LoggingAdvice"/>
    <!-- 定义切点 -->
    <aop:config>
        <!-- 定义通知 -->
        <aop:aspect id="loggingAspect" ref="loggingAdvice">
            <aop:pointcut id="simplePointcut"
                          expression="execution(* org.hulei.spring.xml.aop.xml.PrintService.print())"/>
            <aop:before pointcut-ref="simplePointcut" method="beforeAdvice"/>
        </aop:aspect>
    </aop:config>

    <!-- 一共有三种用于启用 AspectJ 自动代理功能的方式 -->
    <!-- 1. 开启<aop:aspectj-autoproxy/>配置-->
    <!-- 2. 注册AnnotationAwareAspectJAutoProxyCreator这个bean -->
    <!-- 3. 开启@EnableAspectJAutoProxy这个注解 -->
    <!-- Spring 将会自动检测并创建应用程序中使用了 AspectJ 注解的 bean，并将其装配为代理对象，以便应用程序中的切面可以对这些对象进行增强。 -->
    <aop:aspectj-autoproxy/>
</beans>