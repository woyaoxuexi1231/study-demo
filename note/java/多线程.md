### 线程池如何保证线程一直运行, 并等待新任务

线程池内部维护[worker队列], worker队列内的每个worker是一个线程,这些线程会一直尝试在阻塞队列获取任务,获取到任务后,会执行任务的run方法  
内部还维护了一个阻塞队列,阻塞队列用于保存任务.
如果线程执行任务时发生了异常,就ThreadPoolExecutor而言,线程会停止运行.

### ReentrantLock

(基于AbstractQueuedSynchronizer)加锁释放锁过程(源码)

### 线程调度算法有哪些?

线程调度算法用于决定在多线程环境中，哪个线程应该在某一时刻获得CPU时间片并执行。下面是一些常见的线程调度算法：

1. **先来先服务 (First Come First Serve, FCFS)**：
    - 在这种调度算法中，任务按照它们抵达调度器的顺序执行。当一个线程释放CPU后，调度器选择队列中等待时间最长的线程来执行。
    - 这是最简单的调度算法之一，但可能会导致"饥饿"问题，即长任务可能会等待很长时间才能执行。

2. **最短作业优先 (Shortest Job First, SJF)**：
    - 在这种调度算法中，调度器会优先选择执行估计执行时间最短的任务。这个估计可以是实际的执行时间，也可以是预测的执行时间。
    - SJF算法可以最大限度地减少平均等待时间，并且能够有效地避免长任务占用CPU导致的"饥饿"问题。

3. **最短剩余时间优先 (Shortest Remaining Time First, SRTF)**：
    - SRTF算法是SJF的一种抢占式版本。在SRTF中，如果有一个新的任务到达，它的执行时间比当前正在执行的任务剩余执行时间更短，那么调度器会中断当前任务，切换到新任务上。
    - SRTF算法可以确保最小化每个任务的等待时间，但是可能会导致频繁的上下文切换。

4. **轮转调度 (Round Robin)**：
    - 在轮转调度算法中，所有的任务都按照到达时间的顺序排队，并以轮转的方式获得CPU时间片执行。
    - 每个任务执行一个时间片后，它被放到队列的末尾，等待下一个轮转。这样做可以确保公平地分配CPU时间片，避免了长任务占用CPU导致的"饥饿"问题。

5. **多级反馈队列调度 (Multilevel Feedback Queue, MLFQ)**：
    - MLFQ算法是一种结合了轮转调度和优先级调度的算法。在MLFQ中，任务被分成多个优先级队列，每个队列使用不同的调度策略（通常是轮转调度）。
    - 当一个任务进入系统时，它被放入最高优先级的队列。如果一个任务没有在时间片内完成，那么它将被移到下一个更低优先级的队列中。
    - MLFQ算法能够平衡短任务和长任务的执行，同时也能够避免"饥饿"和"过度调度"的问题。

### 如何实现阻塞队列

1. [Object对象的wait()和notify()]
2. [ArrayBlockingQueue] 使用 LockSupport.park(this) 和 LockSupport.unpark(node.thread);

`LockSupport.park()` 和 `LockSupport.unpark(Thread thread)` 是 `java.util.concurrent.locks` 包中的两个方法，用于线程的阻塞和解除阻塞操作。

1. **`park()` 方法**：
    - `park()` 方法用于使当前线程进入阻塞状态，直到另一个线程调用了 `unpark(Thread thread)` 方法将其解除阻塞。`park()` 方法可以在任何地方被调用，而不仅仅是在同步块中。
    - 如果在调用 `park()` 方法之前，线程已经被中断过，则调用 `park()` 方法时会立即返回，不会使线程阻塞。这种情况下，不会消耗线程的中断状态。
    - `park()` 方法还可以带有一个参数，用于指定一个绝对的超时时间，超过这个时间后线程会自动解除阻塞。
    - `park()` 方法可以防止虚假唤醒（spurious wakeups），即使没有调用 `unpark()` 方法，线程也不会在没有原因的情况下自动解除阻塞。

2. **`unpark(Thread thread)` 方法**：
    - `unpark(Thread thread)` 方法用于解除指定线程的阻塞状态，使其可以继续执行。如果线程之前由于调用了 `park()` 方法而被阻塞，调用 `unpark(Thread thread)` 方法后，该线程将被解除阻塞。
    - `unpark(Thread thread)` 方法可以在 `park()` 方法调用之前调用，也可以在 `park()` 方法调用之后调用。即使线程未被阻塞，也可以安全地调用 `unpark()` 方法。
    - `unpark(Thread thread)` 方法不会使线程立即运行，而是设置线程的许可证，使线程在后续的 `park()` 方法调用时能够立即返回，而不会被阻塞。

总之，`LockSupport.park()` 方法用于使当前线程进入阻塞状态，`LockSupport.unpark(Thread thread)` 方法用于解除指定线程的阻塞状态。这两个方法通常用于实现线程间的同步与通信。

### volatile和synchronized关键字

### 如何实现线程间通信

Java 中线程间通信可以通过以下几种方式来实现：

1. **共享变量**：线程之间通过共享变量进行通信。多个线程共享同一个对象的字段，通过读写这些字段来进行通信。但要确保在访问共享变量时进行同步，以避免竞态条件和内存可见性问题。常见的同步机制包括 `synchronized` 关键字和 `volatile` 关键字。

2. **等待/通知机制**：通过 `wait()`、`notify()` 和 `notifyAll()` 方法实现线程间的等待和通知。在使用这种机制时，线程通常持有一个锁对象，并调用该锁对象的 `wait()` 方法使线程等待，在某个条件满足时，调用 `notify()`
   或 `notifyAll()` 方法唤醒等待的线程。这种机制通常与 `synchronized` 关键字一起使用。

3. **阻塞队列**：使用 `java.util.concurrent` 包中的阻塞队列来实现线程间的通信。阻塞队列提供了线程安全的队列操作，并且在队列为空或队列已满时能够自动阻塞或唤醒线程。常用的阻塞队列包括 `ArrayBlockingQueue`、`LinkedBlockingQueue`
   等。

4. **信号量**：使用 `java.util.concurrent` 包中的 `Semaphore` 类来进行线程间通信。信号量可以控制同时访问某个资源的线程数量，并提供了 `acquire()` 和 `release()`
   方法来获取和释放许可证。当许可证数量不足时，线程会被阻塞，直到有足够的许可证可用。

5. **Condition 条件**：使用 `java.util.concurrent.locks` 包中的 `Condition` 接口和 `ReentrantLock` 或 `ReentrantReadWriteLock` 实现线程间的等待和通知。`Condition`
   接口提供了类似于 `wait()` 和 `notify()` 方法的 `await()` 和 `signal()` 方法，可以用于在特定条件下等待和通知线程。

这些方法各有特点，可以根据具体的需求和场景选择合适的方式来实现线程间的通信。

## 什么是CAS

CAS（Compare And Swap，比较并交换）是一种多线程同步的原子操作，常用于实现无锁算法。CAS 操作包括三个参数：内存位置（通常是一个变量的内存地址）、期望值和新值。执行 CAS 操作时，如果内存位置的值与期望值相等，则将该位置的值更新为新值，否则不做任何操作。

CAS 操作通常用于实现线程安全的并发数据结构，例如 AtomicInteger、AtomicLong 和 AtomicReference 等。它的特点是无锁，即使在高并发的情况下，也不需要进行加锁操作，减少了线程间的竞争和争用锁的开销。

在 Java 中，CAS 操作由 `sun.misc.Unsafe` 类提供的一系列方法来实现，例如 `compareAndSwapInt()`、`compareAndSwapLong()` 和 `compareAndSwapObject()` 等。此外，Java 也提供了一些基于 CAS
操作的原子类，例如 `AtomicInteger`、`AtomicLong` 和 `AtomicReference` 等，这些类封装了 CAS 操作，提供了更加易用的接口。

CAS 的优点是它是一种非阻塞的算法，因此在并发量较大的情况下，相较于传统的基于锁的同步方式，CAS 操作的性能更高。然而，CAS 也有一些限制，例如 ABA 问题和循环时间长的问题，需要开发人员在使用 CAS 时注意处理这些问题。
