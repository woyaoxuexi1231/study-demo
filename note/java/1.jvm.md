### 简要介绍一下JVM

Java一次编写,到处运行  
跨平台的 jvm会负责在不同操作系统上帮我们把class文件翻译成对应的指令  
语言无关: 只要是class文件就行

### JVM的解释器和JIT(just-in-time)

Java解释器就是在我们执行代码的过程中,jvm会帮我们把class文件的指令翻译成机器指令,然后执行  
JIT编译器会监视程序的运行情况,根据实际路径和数据来优化,生成更高效的机器代码

### 对象一定是在堆中创建吗?否

### GC的判定方法

1. 引用计数算法: 有一个地方引用的时候就+1,当一个引用失效的时候就-1,当为0的时候就说明对象没有再被使用了.
2. 可达性分析算法: 以GC Roots作为其实节点,从这些节点开始,根据引用关系向下搜索,搜过过程中走过的路径成为引用链,如果某个对象到GCRoots之间没有任何的引用链,那么说明对象没有再被使用了.
   GC Roots: 线程堆栈中的变量,类的静态变量等

### JVM内存分代

新生代: minor GC  
老年代: major GC  
整个Java堆和方法区的垃圾回收: Full GC

### GC的三种收集算法

1. 标记-清除: 首先标记出所有需要回收的对象,在标记完成后,对这些对象进行回收. 缺点:执行效率不稳定,内存空间碎片化
2. 标记-复制: 每次使用一半, 标记处还存活的对象, 然后把这些对象复制到另一半(同时更新引用到新的位置),然后把之前的全部清理掉. 缺点: 空间浪费
3. 标记-整理: 像标记-清楚算法一样,先标记之后然后清理不需要的对象,最后把这些存活对象移动到空间的一端,然后清楚之外的空间. 缺点: 执行效率不高

### 什么是STW, SafePoint

STW: stop the word,在进行垃圾收集的时候,需要暂停所有业务线程  
safepoint: 在一些不会导致引用关系变化的点(各种跳转).设置这些点的好处是,我们去清理垃圾对象的时候,就不会因为用户线程改变了引用关系而导致部分垃圾收集失败
就是线程只有运行到了 SafePoint 的位置，他的一切状态信息，才是确定的，也只有这个时候，才知道这个线程用了哪些内存，没有用哪些；并且，只有线程处于 SafePoint 位置，这时候对 JVM
的堆栈信息进行修改，例如回收某一部分不用的内存，线程才会感知到，之后继续运行，每个线程都有一份自己的内存使用快照，这时候其他线程对于内存使用的修改，线程就不知道了，只有再进行到 SafePoint 的时候，才会感知。

### JVM的垃圾回收器

1. Serial: 新生代单线程垃圾回收器. 采用标记复制算法
2. ParNew: Serial收集器的多线程并行版本(新生代). 采用复制算法
3. Parallel Scavenge: 新生代收集器. 和ParNew类似,也是一个多线程并发收集器,更关注用户代码执行的吞吐量(用户执行代码的时间/(用户代码执行时间+垃圾回收时间)).而其他垃圾回收器则更关注怎么样减少STW的时间
4. Serial Old: 老年代单线程垃圾回收器. 采用标记-整理算法
5. Parallel Old: 老年代多线程收集器. 是Parallel Scavenge的老年代版本.采用标记整理算法
6. CMS: 基于标记-清楚算法.以获取最短回收停顿时间为目标的垃圾收集器. 让垃圾回收线程和用户线程同时进行作业.
   初始化标记(只标记root直连对象,stw)->并发标记(业务线程和垃圾回收线程同时跑,垃圾回收线程遍历所有对象进行标记)->重新标记(修正并发标记阶段业务线程引起变化的标记,stw)->并发清理(业务线程与垃圾回收线程同时进行)
   三色标记法(在并发的可达性分析下,会存在漏标的情况)->cms使用重新标记来修正
   优点: 暂停时间短
   缺点: 对CPU敏感,无法处理浮动垃圾(设置触发阈值,92%已使用就赶紧触发GC),内存碎片很多
7. G1: 面向局部回收的设计和基于Region的内存布局设计. todo
   内存空间被分成大小相等的块,并根据需要随意扮演 e,s,o等区域,然后会分析每个区谁的垃圾最多.谁的垃圾多就处理谁
   三色标记法(在并发的可达性分析下,会存在漏标的情况)->SATB(snapshot-at-the-beginning)在引用关系发生变化的时候把删除关系保存下来,在GC的时候会检查这个列表来判断这些对象是不是又被其他对象引用了.

### JVM运行时数据区

线程私有区域: 程序计数器,本地方法栈,虚拟机栈  
线程共享区域: 堆(新生代(e,s+s),老年代),方法区(还包含运行时常量池)

### jvm内存溢出

* 栈溢出 - 压栈过深了,栈一般来说1000-2000完全够了,jvm默认1m
* 堆溢出 - 堆内对象太多了,又回收不了,就堆溢出了,单纯的虚拟机内存分配不足或者是机器本身就不够
* 方法区溢出
* 本机直接内存溢出

### 什么是内存泄漏,哪些情况可能会导致内存泄漏

原本已经不适用的内存空间,但是却没有释放,并且回收不了.那么就产生了内存泄漏

### 对象的内存布局

首先,一个对象在堆内存的布局大概分为三个部分: 1.对象头,2.示例数据,3.对齐填充  
**对象头** 大小在32比特或者64比特   
一类是用于存储对象自身运行时的数据(哈希码,GC分代年龄,锁状态标志,线程持有状态,偏向锁ID,偏向时间戳等等)  
第二类是类型指针,即对象指向他的类型元数据的指针(Java虚拟机通过这个来确定这个对象是哪个类的实例,并非所有的虚拟机都必须在对象数据上保存类型指针)  
**实例数据** 真正存储对象数据的(会包含父类的)  
**对其填充** 对象头被设计成正好是8的倍数,为了满足这个设计,而存在的

### 给一个具体的类,分析对象的内存占用

### JVM的一些常见启动参数

-Xmx40m/4g  
-Xms40M/4G  
-XX:+UseG1GC -XX:MaxGCPauseMillis=50  
-XX:ParallelGCThreads=4 设置并行垃圾收集器线程数目。  
-XX:+PrintGCDetails

-Xmx: 设置Java堆的最大内存大小。  
-Xms: 设置Java堆的初始内存大小。  
-Xss: 设置每个线程的栈大小。  
-XX:PermSize / -XX:MaxPermSize: 设置持久代（Java 8之前）的初始大小和最大大小。  
-XX:MetaspaceSize / -XX:MaxMetaspaceSize: 设置元空间（Java 8及更高版本）的初始大小和最大大小。  
-XX:NewSize / -XX:MaxNewSize: 设置新生代的初始大小和最大大小。  
-XX:SurvivorRatio: 设置Eden区与Survivor区的比率。  
-XX:MaxTenuringThreshold: 设置对象晋升到老年代之前在新生代的最大存活次数。  
-XX:InitialCodeCacheSize / -XX:ReservedCodeCacheSize: 设置初始代码缓存大小和保留代码缓存大小。  
-XX:MaxDirectMemorySize: 设置直接内存的最大大小。  
-XX:ParallelGCThreads: 设置并行垃圾收集器线程数目。  
-XX:+UseConcMarkSweepGC: 启用CMS垃圾收集器。  
-XX:+UseG1GC: 启用G1垃圾收集器。  
-XX:+UseSerialGC: 启用串行垃圾收集器。  
-XX:CompileThreshold: 设置即时编译的阈值。  
-XX:CICompilerCount: 设置并行编译器的数量。  
-XX:+PrintGCDetails: 打印详细的垃圾收集信息。  
-XX:+HeapDumpOnOutOfMemoryError: 当发生内存溢出时自动生成堆转储文件。

### 类的加载过程

加载->连接(验证->准备->解析)->初始化->使用->卸载

**加载**(读文件): 通过一个类的全限定名来获取class文件的二进制字节流->将这个字节流所代表的静态存储结构方法转化成方法区的运行时数据结构->在内存中生成一个代表这个类的java.lang.class对象,作为方法去这个类的各种数据的访问入口  
**验证**(读了,但是需要判断给的东西是不是符合规范):确保class文件的字节流中包含的信息是符合规范和约束的  
**准备**(类的静态变量申请空间和设置初始值)  
**解析**(符号引用变成直接引用)  
**初始化**:给静态变量赋值->调用对象的构造方法  
**使用**.  
**卸载**.

### 什么是双亲委派机制,具体有什么作用?

**BootStrap**(rt.jar)最顶层 - **Extension**(扩展加载器,jre/lib...) - 应用程序类加载器

如果一个类加载器收到了一个类加载的请求,它首先不会加载这个类,而是把它委派给父类加载器去完成,每一个层次的加载器都如此.  
只有当最上级的父类加载器尝试加载却无法记载时,会向下反馈,然后一级级向下传递

1. **通过带有优先级的层级关系可以避免类的重复加载**
2. **保证Java程序的安全稳定运行, Java核心的API定义不会被随意的替换**

### Java内存模型和线程

Java内存模型（Java Memory Model，简称JMM）是一种规范，定义了Java程序中多线程并发访问共享内存的行为。它规定了在多线程环境下，如何进行内存的读写操作以及线程之间如何进行通信，以确保程序在不同平台上的一致性和可预测性。

JMM 主要包含以下几个方面的内容：

1. **主内存（Main Memory）：** 主内存是所有线程共享的内存区域，用于存储 Java 对象实例、静态变量等数据。所有的线程都可以访问主内存中的数据。

2. **工作内存（Working Memory）：** 每个线程都拥有自己的工作内存，用于存储主内存中的部分数据副本。线程对数据的读写操作都是在工作内存中进行的，而不直接在主内存中操作。

Java 内存模型的设计旨在提供一种统一的并发编程规范，使得开发者能够编写出线程安全的、正确的并发程序。通过遵循 JMM 规范，可以确保在不同的 JVM 实现上，程序的行为是一致的。

[Java内存模型（JMM）总结](Java内存模型.mhtml) 这篇文章写得很好

---
---
---

### 关于Spring

1. String 是一个不可变的类，表示字符序列. 使用双引号 "" 创建字符串时，我们实际上是在直接使用一个字符串字面量

   在Java中，除了String类被设计成不可变的之外，基本类型的包装类（如Integer、Double、Boolean等）也是不可变的。这意味着一旦创建了这些对象，它们的值就不能被修改。

   这种设计有着类似于字符串不可变性的优势：

    1. **线程安全性：** 不可变对象可以在多线程环境中安全地共享，因为它们的值不会改变。

    2. **缓存利用：** 因为不可变对象的值不会改变，所以它们可以被安全地缓存，以便在多次使用时重复利用。

    3. **参数传递：** 不可变对象在作为方法参数传递时更加安全，因为调用者不必担心对象在方法中被修改。

    4. **Hash算法安全：** 不可变对象的哈希值是固定的，因此可以安全地用作哈希映射的键。

   虽然在某些情况下，可变对象可能会提供更灵活的解决方案，但不可变对象的设计可以减少代码中的错误，并促进更好的线程安全性和可维护性。

### ~~main为什么必须是静态的(涉及jvm,作为jvm的入口,必须具备无需实例化,类被加载时立即可用)~~

### ~~动态绑定(（也称为晚期绑定或运行时多态性）是一种在运行时（而非编译时）确定要调用方法的对象的机制)~~

### cpu负载过高,如何排查

jstack的使用,dump日志的解析

### jvm oom了如何排查

1. 一个拥有一百多万行的excel(大小也就6M),上传后使用XSSFWorkbook进行解析之后,内存涨到了3个G,后续导致调用rpc接口OOM
   XSSFWorkbook会创建大量的对象,当然excel本身数据也有点太多了

### 大概计算内存占用大小

如果一个对象内有一个Integer和一个String，String最大长度是100个字符（可能是中文可能是英文），我有100个这样的对象，大概占多大的内存?

1. **Integer 对象**：一个 Integer 对象通常占用 16 字节的对象头，再加上 4 字节的 int 值。所以，一个 Integer 对象的内存开销为 20 字节。
2. **String 对象**：一个 String 对象通常占用 40 字节的对象头，再加上 一个 char[] 对象引用（8 字节）和 3 个 int 类型字段（总共 12 字节），以及一个 int 字段（存储字符串长度，4 字节），再加上 char[]

数组占用的内存空间（根据字符串长度而定）。假设每个字符占用 2 字节，那么一个 String 对象的平均内存开销为：

String 对象的内存开销 = 40 字节（对象头） + 8 字节（char[] 对象引用） + 12 字节（字段） + 4 字节（存储长度） + 100（假设每个字符串长度为 100 个字符） * 2 字节（每个字符占用 2 字节）

String 对象的内存开销 ≈ 40 字节 + 8 字节 + 12 字节 + 4 字节 + 200 字节 = 264 字节

因此，100 个对象中 Integer 和 String 类型的总内存开销为：

100 * (20 字节 + 264 字节) = 28400 字节

再加上对象本身的内存开销，总内存开销为：

1600 字节 + 28400 字节 = 30000 字节

所以，大约占用 30 KB 左右的内存空间。感谢您的指正，希望这次的计算是正确的。