## 基础

### 简要介绍一下JVM

Java一次编写,到处运行  
跨平台的 jvm会负责在不同操作系统上帮我们把class文件翻译成对应的指令  
语言无关: 只要是class文件就行

### JVM的解释器和JIT(just-in-time)

Java解释器就是在我们执行代码的过程中,jvm会帮我们把class文件的指令翻译成机器指令,然后执行  
JIT编译器会监视程序的运行情况,根据实际路径和数据来优化,生成更高效的机器代码

## 内存管理

### JVM运行时数据区

线程私有区域: 程序计数器,本地方法栈,虚拟机栈  
线程共享区域: 堆(新生代(e,s+s),老年代),方法区(还包含运行时常量池)

### JVM内存分代

新生代: minor GC  
老年代: major GC  
整个Java堆和方法区的垃圾回收: Full GC

### GC的判定方法

1. 引用计数算法: 有一个地方引用的时候就+1,当一个引用失效的时候就-1,当为0的时候就说明对象没有再被使用了.
2. 可达性分析算法: 以GC Roots作为其实节点,从这些节点开始,根据引用关系向下搜索,搜过过程中走过的路径成为引用链,如果某个对象到GCRoots之间没有任何的引用链,那么说明对象没有再被使用了.
   GC Roots: 线程堆栈中的变量,类的静态变量等

### GC的三种收集算法

1. 标记-清除: 首先标记出所有需要回收的对象,在标记完成后,对这些对象进行回收. 缺点:执行效率不稳定,内存空间碎片化
2. 标记-复制: 每次使用一半, 标记处还存活的对象, 然后把这些对象复制到另一半(同时更新引用到新的位置),然后把之前的全部清理掉. 缺点: 空间浪费
3. 标记-整理: 像标记-清楚算法一样,先标记之后然后清理不需要的对象,最后把这些存活对象移动到空间的一端,然后清楚之外的空间. 缺点: 执行效率不高

### 什么是STW, SafePoint

STW: stop the word,在进行垃圾收集的时候,需要暂停所有业务线程  
safepoint: 在一些不会导致引用关系变化的点(各种跳转).设置这些点的好处是,我们去清理垃圾对象的时候,就不会因为用户线程改变了引用关系而导致部分垃圾收集失败
就是线程只有运行到了 SafePoint 的位置，他的一切状态信息，才是确定的，也只有这个时候，才知道这个线程用了哪些内存，没有用哪些；并且，只有线程处于 SafePoint 位置，这时候对 JVM
的堆栈信息进行修改，例如回收某一部分不用的内存，线程才会感知到，之后继续运行，每个线程都有一份自己的内存使用快照，这时候其他线程对于内存使用的修改，线程就不知道了，只有再进行到 SafePoint 的时候，才会感知。

### JVM的垃圾回收器

| 垃圾回收器          | 类型             | 主要回收区域 | 出现时间 | 解决的问题                                                                                                                                                                                                                               | 存在的问题                                                   | 适用场景                                            |
|--------------------|-----------------|-------------|--------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------|----------------------------------------------------|
| Serial GC          | 标记-整理（单线程）  | 年轻代       | JDK 1.3 | 解决了简单应用的垃圾收集，易于实现                                                                                                                                                                                                                   | 停止世界（stop-the-world）长暂停，不适合多核心处理器         | 小型应用或开发环境，单核处理器或小堆内存               |
| Serial Old         | 标记-整理（单线程）  | 老年代       | JDK 1.3 | 用作更大应用的老年代垃圾收集                                                                                                                                                                                                                      | 同Serial GC，长暂停时间                                      | 较老的系统或作为CMS的后备方案                        |
| Parallel GC        | 标记-整理（多线程）  | 年轻代       | JDK 1.4 | 提高吞吐量，利用多核性能，更关注用户代码执行的吞吐量(用户执行代码的时间/(用户代码执行时间+垃圾回收时间))。而其他垃圾回收器则更关注怎么样减少STW的时间                                                                                                                                                     | 高GC暂停时间仍可能影响用户体验                               | 多核服务器环境，注重吞吐量，可以容忍较长GC暂停          |
| Parallel Old       | 标记-整理（多线程）  | 老年代       | JDK 1.6 | 扩展Parallel GC到老年代，进一步提高吞吐量                                                                                                                                                                                                          | 分享Parallel GC的问题，即较长GC暂停                         | 大型应用且需要高吞吐量的环境                           |
| Concurrent Mark Sweep (CMS) | 标记-清除     | 老年代       | JDK 1.4 | 初始化标记(只标记root直连对象,stw)->并发标记(业务线程和垃圾回收线程同时跑,垃圾回收线程遍历所有对象进行标记)->重新标记(修正并发标记阶段业务线程引起变化的标记,stw)->并发清理(业务线程与垃圾回收线程同时进行)，<br>三色标记法(在并发的可达性分析下,会存在漏标的情况)->cms使用重新标记来修正 <br>优点: 暂停时间短 <br>缺点: 对CPU敏感,无法处理浮动垃圾(设置触发阈值,92%已使用就赶紧触发GC),内存碎片很多 | 产生内存碎片，'Concurrent Mode Failure'，维护成本高        | 需要较短GC停顿的WEB或应用服务器                        |
| ParNew             | 标记-复制（多线程）  | 年轻代       | JDK 1.4 | 为了更好地服务多处理器机器与CMS的搭配比Serial GC更优                                                                                                                                                                                                    | 停停顿时间较长，不适合大堆内存                               | 多核心处理器且小到中等堆内存，需要较短GC停顿时间       |
| Parallel Scavenge  | 标记-复制（多线程）  | 年轻代       | JDK 1.4 | 自适应调整策略，自动选择最优暂停时间和吞吐量的平衡                                                                                                                                                                                                           | 不适用于需要最小化GC停顿时间的应用                           | 对吞吐量有高要求，适合在后台运算而不需要太多交互的任务  |
| G1 (Garbage First) | 区域化的标记-整理复制 | 整个堆       | JDK 1.7 | 解决了大内存系统中长暂停时间问题，提高预测性                                                                                                                                                                                                              | 初始化配置较复杂，可能出现性能下降                           | 大内存，多核服务器，追求低延迟和高吞吐量             |
| ZGC (Z Garbage Collector) | 标记-压缩       | 整个堆       | JDK 11 | 提供极低停顿时间，适合大内存应用                                                                                                                                                                                                                    | 目前尚处于实验阶段，未被广泛采用                             | 实验或最新版本JVM，大内存管理需求                     |
| Shenandoah        | 标记-压缩       | 整个堆       | JDK 12 | 目标是进一步减少GC停顿时间，独立于堆大小进行GC                                                                                                                                                                                                           | 同样处于较新状态，可能在具体系统中遇到问题                    | 大内存应用，需要非常低的暂停时间                        |

从历史的发展角度来看，垃圾回收器的搭配和推荐使用方式在Java的不同版本间有了显著的演变。

**起始阶段**
在JDK 1.3时代，最基础的垃圾回收器包括Serial GC，它主要用于单核处理器或者资源较少的环境。这时，对于老年代的GC，会默认使用Serial Old GC。这种搭配主要是因为那时的硬件和应用的规模尚未大幅度扩展。

**进化阶段**
进入JDK 1.4和JDK 1.6，出现了更多针对多核处理器和服务器环境优化的垃圾回收器。比如Parallel GC（针对年轻代）和Parallel Old
GC（针对老年代），这两者一起使用，提供了针对多核服务器环境更好的吞吐性能。同时，CMS的引入针对需要低延迟的应用提供了选项，通常与ParNew GC结合使用来处理年轻代，以保持较短的停顿时间。

**现代推荐组合**
从JDK 7引入的G1 GC开始，垃圾回收技术发生了重大变革。G1 GC旨在替代老一代的CMS加ParNew的组合，同时提供对整个堆的高效管理，包括年轻代和老年代。它通过分区的方式，尽量平衡吞吐量和响应时间，适合大内存和多核心处理器的环境。

**最新进展**
JDK 11及之后，引入了ZGC和Shenandoah GC，这些都是面向未来的垃圾回收技术，专注于几乎消除GC停顿时间，适用于高要求的大内存应用，并且继续支持多核心处理器优化。

**总结**

- **起始阶段**：Serial GC和Serial Old。
- **服务器优化**：Parallel GC和Parallel Old，CMS加ParNew。
- **现代大内存应用**：G1 GC。
- **最新技术**：ZGC和Shenandoah。

选择和搭配应基于具体应用的需求，包括处理器的核心数、应用的内存需求以及对延迟的敏感度。随着新型垃圾回收技术的引入，Java JVM的性能和效率持续提升，允许开发者针对不同的应用场景选择最合适的GC策略。

### 对象一定是在堆中创建吗?否

### jvm内存溢出

* 栈溢出 - 压栈过深了,栈一般来说1000-2000完全够了,jvm默认1m
* 堆溢出 - 堆内对象太多了,又回收不了,就堆溢出了,单纯的虚拟机内存分配不足或者是机器本身就不够
* 方法区溢出
* 本机直接内存溢出

### 什么是内存泄漏,哪些情况可能会导致内存泄漏

原本已经不适用的内存空间,但是却没有释放,并且回收不了.那么就产生了内存泄漏

### 对象的内存布局

首先,一个对象在堆内存的布局大概分为三个部分: 1.对象头,2.示例数据,3.对齐填充  
**对象头** 大小在32比特或者64比特   
一类是用于存储对象自身运行时的数据(哈希码,GC分代年龄,锁状态标志,线程持有状态,偏向锁ID,偏向时间戳等等)  
第二类是类型指针,即对象指向他的类型元数据的指针(Java虚拟机通过这个来确定这个对象是哪个类的实例,并非所有的虚拟机都必须在对象数据上保存类型指针)  
**实例数据** 真正存储对象数据的(会包含父类的)  
**对其填充** 对象头被设计成正好是8的倍数,为了满足这个设计,而存在的

### 给一个具体的类,分析对象的内存占用

**基本类型**

在Java中，基本数据类型的大小是固定的，它们所占的字节数如下所示：

byte: 1字节  
short: 2字节    
int: 4字节  
long: 8字节  
float: 4字节  
double: 8字节  
char: 2字节  
boolean: 在实际存储时，可能占用不定大小，但一般认为是1字节  
这些基本数据类型的大小是根据Java虚拟机规范确定的，这些大小是跨平台的，不会因为不同操作系统或机器架构而有所变化。当然，这些数据类型的大小可能在不同的Java实现中有所不同，但一般遵循上述规定。

**封装的基本类型**

1. 对象头 32位或64位 即4个字节或者八个字节
2. 封装的基本类型和基本类型的大小差不多一致

**对象**

对象的大小计算也就是对象头+所有的字段

如果一个对象内有一个Integer和一个String，String最大长度是100个字符（可能是中文可能是英文），我有100个这样的对象，大概占多大的内存?

1. **Integer 对象**：一个 Integer 对象通常占用 16 字节的对象头，再加上 4 字节的 int 值。所以，一个 Integer 对象的内存开销为 20 字节。
2. **String 对象**：一个 String 对象通常占用 40 字节的对象头，再加上 一个 char[] 对象引用（8 字节）和 3 个 int 类型字段（总共 12 字节），以及一个 int 字段（存储字符串长度，4
   字节），再加上 char[]

数组占用的内存空间（根据字符串长度而定）。假设每个字符占用 2 字节，那么一个 String 对象的平均内存开销为：

String 对象的内存开销 = 40 字节（对象头） + 8 字节（char[] 对象引用） + 12 字节（字段） + 4 字节（存储长度） + 100（假设每个字符串长度为 100 个字符） * 2 字节（每个字符占用 2 字节）

String 对象的内存开销 ≈ 40 字节 + 8 字节 + 12 字节 + 4 字节 + 200 字节 = 264 字节

因此，100 个对象中 Integer 和 String 类型的总内存开销为：

100 * (20 字节 + 264 字节) = 28400 字节

再加上对象本身的内存开销，总内存开销为：

1600 字节 + 28400 字节 = 30000 字节

所以，大约占用 30 KB 左右的内存空间。感谢您的指正，希望这次的计算是正确的。

## 虚拟机执行子系统

### 类的加载过程

加载->连接(验证->准备->解析)->初始化->使用->卸载

**加载**(读文件): 通过一个类的全限定名来获取class文件的二进制字节流->将这个字节流所代表的静态存储结构方法转化成方法区的运行时数据结构->
在内存中生成一个代表这个类的java.lang.class对象,作为方法去这个类的各种数据的访问入口  
**验证**(读了,但是需要判断给的东西是不是符合规范):确保class文件的字节流中包含的信息是符合规范和约束的  
**准备**(类的静态变量申请空间和设置初始值)  
**解析**(符号引用变成直接引用)  
**初始化**:给静态变量赋值->调用对象的构造方法  
**使用**.  
**卸载**.

### 什么是双亲委派机制,具体有什么作用?

**BootStrap**(rt.jar)最顶层 - **Extension**(扩展加载器,jre/lib...) - 应用程序类加载器

如果一个类加载器收到了一个类加载的请求,它首先不会加载这个类,而是把它委派给父类加载器去完成,每一个层次的加载器都如此.  
只有当最上级的父类加载器尝试加载却无法记载时,会向下反馈,然后一级级向下传递

1. **通过带有优先级的层级关系可以避免类的重复加载**
2. **保证Java程序的安全稳定运行, Java核心的API定义不会被随意的替换**

## 并发

### Java内存模型和线程

Java内存模型（Java Memory
Model，简称JMM）是一种规范，定义了Java程序中多线程并发访问共享内存的行为。它规定了在多线程环境下，如何进行内存的读写操作以及线程之间如何进行通信，以确保程序在不同平台上的一致性和可预测性。

JMM 主要包含以下几个方面的内容：

1. **主内存（Main Memory）：** 主内存是所有线程共享的内存区域，用于存储 Java 对象实例、静态变量等数据。所有的线程都可以访问主内存中的数据。

2. **工作内存（Working Memory）：** 每个线程都拥有自己的工作内存，用于存储主内存中的部分数据副本。线程对数据的读写操作都是在工作内存中进行的，而不直接在主内存中操作。

Java 内存模型的设计旨在提供一种统一的并发编程规范，使得开发者能够编写出线程安全的、正确的并发程序。通过遵循 JMM 规范，可以确保在不同的 JVM 实现上，程序的行为是一致的。

[Java内存模型（JMM）总结](Java内存模型.mhtml) 这篇文章写得很好

### 线程的可见性(Java的内存模型),原子性和有序性(防止指令重排序)

---
---
---

## 问题排查

### ~~main为什么必须是静态的(涉及jvm,作为jvm的入口,必须具备无需实例化,类被加载时立即可用)~~

### ~~动态绑定(（也称为晚期绑定或运行时多态性）是一种在运行时（而非编译时）确定要调用方法的对象的机制)~~

### cpu负载过高,如何排查

jstack的使用,dump日志的解析

### jvm oom了如何排查

1. 一个拥有一百多万行的excel(大小也就6M),上传后使用XSSFWorkbook进行解析之后,内存涨到了3个G,后续导致调用rpc接口OOM
   XSSFWorkbook会创建大量的对象,当然excel本身数据也有点太多了

## JVM的一些常见启动参数

-Xmx40m/4g  
-Xms40M/4G  
-XX:+UseG1GC -XX:MaxGCPauseMillis=50  
-XX:ParallelGCThreads=4 设置并行垃圾收集器线程数目。  
-XX:+PrintGCDetails

-Xmx: 设置Java堆的最大内存大小。  
-Xms: 设置Java堆的初始内存大小。  
-Xss: 设置每个线程的栈大小。  
-XX:PermSize / -XX:MaxPermSize: 设置持久代（Java 8之前）的初始大小和最大大小。  
-XX:MetaspaceSize / -XX:MaxMetaspaceSize: 设置元空间（Java 8及更高版本）的初始大小和最大大小。  
-XX:NewSize / -XX:MaxNewSize: 设置新生代的初始大小和最大大小。  
-XX:SurvivorRatio: 设置Eden区与Survivor区的比率。  
-XX:MaxTenuringThreshold: 设置对象晋升到老年代之前在新生代的最大存活次数。  
-XX:InitialCodeCacheSize / -XX:ReservedCodeCacheSize: 设置初始代码缓存大小和保留代码缓存大小。  
-XX:MaxDirectMemorySize: 设置直接内存的最大大小。  
-XX:ParallelGCThreads: 设置并行垃圾收集器线程数目。  
-XX:+UseConcMarkSweepGC: 启用CMS垃圾收集器。  
-XX:+UseG1GC: 启用G1垃圾收集器。  
-XX:+UseSerialGC: 启用串行垃圾收集器。  
-XX:CompileThreshold: 设置即时编译的阈值。  
-XX:CICompilerCount: 设置并行编译器的数量。  
-XX:+PrintGCDetails: 打印详细的垃圾收集信息。  
-XX:+HeapDumpOnOutOfMemoryError: 当发生内存溢出时自动生成堆转储文件。

