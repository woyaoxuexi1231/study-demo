### 简要介绍一下JVM

Java一次编写,到处运行
跨平台的 jvm会负责在不同操作系统上帮我们把class文件翻译成对应的指令
语言无关: 只要是class文件就行

### JVM的解释器和JIT(just-in-time)

Java解释器就是在我们执行代码的过程中,jvm会帮我们把class文件的指令翻译成机器指令,然后执行  
JIT编译器会监视程序的运行情况,根据实际路径和数据来优化,生成更高效的机器代码

### 对象一定是在堆中创建吗?否

### GC的判定方法

1. 引用计数算法: 有一个地方引用的时候就+1,当一个引用失效的时候就-1,当为0的时候就说明对象没有再被使用了.
2. 可达性分析算法: 以GC Roots作为其实节点,从这些节点开始,根据引用关系向下搜索,搜过过程中走过的路径成为引用链,如果某个对象到GCRoots之间没有任何的引用链,那么说明对象没有再被使用了.
   GC Roots: 线程堆栈中的变量,类的静态变量等

### JVM内存分代

新生代: minor GC
老年代: major GC
整个Java堆和方法区的垃圾回收: Full GC

### GC的三种收集算法

1. 标记-清除: 首先标记出所有需要回收的对象,在标记完成后,对这些对象进行回收. 缺点:执行效率不稳定,内存空间碎片化
2. 标记-复制: 每次使用一半, 标记处还存活的对象, 然后把这些对象复制到另一半(同时更新引用到新的位置),然后把之前的全部清理掉. 缺点: 空间浪费
3. 标记-整理: 像标记-清楚算法一样,先标记之后然后清理不需要的对象,最后把这些存活对象移动到空间的一端,然后清楚之外的空间. 缺点: 执行效率不高

### 什么是STW, SafePoint

STW: stop the word,在进行垃圾收集的时候,需要暂停所有业务线程
safepoint: 在一些不会导致引用关系变化的点(各种跳转).

### JVM的垃圾回收器

1. Serial: 新生代单线程垃圾回收器. 采用标记复制算法
2. ParNew: Serial收集器的多线程并行版本(新生代). 采用复制算法
3. Parallel Scavenge: 新生代收集器. 和ParNew类似,也是一个多线程并发收集器,更关注用户代码执行的吞吐量(用户执行代码的时间/(用户代码执行时间+垃圾回收时间)).而其他垃圾回收器则更关注怎么样减少STW的时间
4. Serial Old: 老年代单线程垃圾回收器. 采用标记-整理算法
5. Parallel Old: 老年代多线程收集器. 是Parallel Scavenge的老年代版本.采用标记整理算法
6. CMS: 基于标记-清楚算法.以获取最短回收停顿时间为目标的垃圾收集器. 让垃圾回收线程和用户线程同时进行作业.
   初始化标记(只标记root直连对象,stw)->并发标记(业务线程和垃圾回收线程同时跑,垃圾回收线程遍历所有对象进行标记)->重新标记(修正并发标记阶段业务线程引起变化的标记,stw)->并发清理(业务线程与垃圾回收线程同时进行)
   优点: 暂停时间短
   缺点: 对CPU敏感,无法处理浮动垃圾(设置触发阈值,92%已使用就赶紧触发GC),内存碎片很多
7. G1: 面向局部回收的设计和基于Region的内存布局设计. todo
   内存空间被分成大小相等的块,并根据需要随意扮演 e,s,o等区域,然后会分析每个区谁的垃圾最多.谁的垃圾多就处理谁

### JVM运行时数据区

线程私有区域: 程序计数器,本地方法栈,虚拟机栈
线程共享区域: 堆(新生代(e,s+s),老年代),方法区(还包含运行时常量池)

### jvm内存溢出

* 栈溢出 - 压栈过深了,栈一般来说1000-2000完全够了,jvm默认1m
* 堆溢出 - 堆内对象太多了,又回收不了,就堆溢出了,单纯的虚拟机内存分配不足或者是机器本身就不够
* 方法区溢出
* 本机直接内存溢出

### 什么是内存泄漏,哪些情况可能会导致内存泄漏

原本已经不适用的内存空间,但是却没有释放,并且回收不了.那么就产生了内存泄漏

### 对象的对象头

### 给一个具体的类,分析对象的内存占用

### 类的加载过程

### Java内存模型和线程

### 关于String的一些冷知识, String 是一个不可变的类，表示字符序列. 使用双引号 "" 创建字符串时，我们实际上是在直接使用一个字符串字面量

### ~~main为什么必须是静态的(涉及jvm,作为jvm的入口,必须具备无需实例化,类被加载时立即可用)~~

### ~~动态绑定(（也称为晚期绑定或运行时多态性）是一种在运行时（而非编译时）确定要调用方法的对象的机制)~~
