spring创建一个bean的流程
获取bean定义(不论是xml形式还是注解形式)->注册一些处理器->doGetBean(如果没有)->doCreateBean->创建bean之前会调用处理器的前置处理操作->实例化bean->



singletonObjects(一级缓存,这里只存放完全初始化完成的bean,也就是完成了实例化,完成了初始化)
earlySingletonObjects(二级缓存,这里只存放提前曝光的bean,只是完成了实例化,但是没有完成初始化,可能是原始对象,也可能是代理对象)
singletonFactories(三级缓存,这里存放的是可以生产一个实例化好的bean的工厂,目的是为了延迟创建对象.)
registeredSingletons - 已经注册在案的 Bean(可能是完成实例化没有初始化的Bean, 也可以能是完全创建好的Bean)

1. Bean 开始创建的阶段会首先检查三级缓存 - singletonObjects(一级缓存) -> earlySingletonObjects(二级缓存) -> singletonFactories(三级缓存), 按照这个顺序找 Bean
   一级和二级缓存找到后会直接返回, 如果在三级缓存找到, 会把三级缓存内的移除, 添加到二级缓存
2. Bean被实例化后 - 放入三级缓存(放入的同时, 会创建好完整的代理对象, 也就是说, 后面命中缓存拿到的也是代理对象), 并在二级缓存中移除, 因为这意味着全新的 Bean 被创建, 之前的理应丢弃 - todo 如果在这之前, 有其他 bean 引用了二级缓存的 bean 怎么办??
   2023-02-11
3. Bean被初始化之后 -> 放入一级缓存, 并移除二级缓存和三级缓存

在bean的实例被创建好之后会在earlyProxyReferences放入对应的beanName+bean
并且进行下面的创建代理对象的操作 ↓
创建代理对象的步骤(为什么要每次都创建新的代理? 因为spring里的对象可能被代理多次, 且都使用同一个名字)

1. 判断一下 targetSourcedBeans 有没有,
2. 判断一下 advisedBeans 有没有 FALSE
3. 如果当前bean需要被代理, 那么在 advisedBeans 放入 beanName+true
4. 代理对象创建好之后在 proxyTypes 里添加 beanName+proxyClass
   到这里, 提前暴露的已经是这个beanName对应的代理对象了
   创建好对象之后, 执行后置操作, 发现这个对象需要创建相应的代理对象, 判断 earlyProxyReferences 中移除当前这个 beanName的对象, 如果移除的对象和当前对象相同, 那么直接返回, 如果不相同, 那么创建代理对象

假设只有一级和三级缓存, 没有二级缓存, 其他逻辑不变
那么 初始化之后的后置操作将不会生成代理对象
假设只有一级和三级缓存, 没有二级缓存, 做点手脚
但是会有以下情况

1. 首先, 我们无法在proxyTypes中进行判断, 因为使用字节码生成的class,名字是确定的
2. 如果我们使用earlyProxyReferences来进行判断, 每次进来如果发现 beanName+bean跟上一次一样, 就在proxyTypes里面拿代理对象
   以上两点, 看上去好像可行, 其实不行, 被代理后的bean还有其他切面怎么办? 还得继续代理, 继续进来beanName+bean百分之百一样, 但是还需要继续创建新的代理对象,是不能通过这个来判断的
   综上也就是说二级缓存的思路基本死亡

而三级缓存的好处在哪里, 在我们确定好一个代理对象之后, 第一次在三级缓存中找到这个代理对象的时候, 就会把他放入二级缓存(Map<String,Object>), 这样, 命中二级缓存会直接拿这个代理后的对象
