# 一面

1. Java泛型

2. Java集合- hashmap和list扩容源码
   arrayList扩容的力度为会扩容为原来的1.5倍 int newCapacity = oldCapacity + (oldCapacity >> 1);
   如果说一次性加大量元素,扩容1.5倍仍然不够,那么新的数组长度是原来的长度+新数组的长度
3. spring自动配置的原理
   spring.factory实现
4. springboot启动流程
5. spring循环依赖
6. 设计模式用了哪些 在项目里面怎么使用的
7. redis数据结构
8. redis实现排行榜
   使用redis提供的有序集合可以很方便的实现这种功能

# 二面 面试官小贱,表情管理差

1. redis队列的使用场景他举了一个例子，关注列表的例子，用户a关注了两个人，用户b关注了三个人，怎么知道这两个用户共同关注了谁
   没答上
   这个其实他说错了，并不是redis的队列，而是redis的set集合才有这种功能，set有相关的api可以直接用
   redis提供了intersect,union,difference三个命令分别求交集,并集和差集
2. redis分布式锁的具体实现 心跳机制如何检测主线程的还在执行中 没答上
3. redis穿透 雪崩 没答好
   先要搞明白穿透和雪崩分别对应什么场景,分别表明了redis的什么问题
   如果说数据一切正常,redis和mysql都有一份,那么正常来说是没什么问题的,但是对于数据来说可能存在两个问题
   1.查询的数据是否真实的存在
   2.查询的数据在缓存内是否过期
   这两个问题会引入穿透和雪崩的问题
   1.穿透顾名思义就是说redis和mysql都没有,整个穿透了,对于这种不存在的数据,我们可以缓存空对象或者布隆过滤器
   2.对于雪崩,我说雪崩可能由于redis服务不可用导致,面试官表示难以置信,给我整蒙了,对于雪崩,不管是服务不可用还是大量键过期,最终的结果就是大量的请求即将到达db,
   解决方法一般分散缓存的失效时间(随机过期,或者其他方案),限流,降级,预热等方案

4. 两个数如何在不生成第三个临时数的情况下互换值 没答上 我知道肯定是位运算但是当时短时间反应不过来怎么算 其实三次异或运算就解决了

5. 类加载机制的详细过程
   说实话,我没想到他让我特别详细的说一下类加载机制的详细过程,这个确实不太熟悉
    - <b>加载</b>
      通过全限定类名获取定义此类的二进制文件流(
      这个东西可以在很多地方获取,我们打包的jar包,在网络中获取,实时生成都可以,比如cglib代理,还有jsp生成的类)
      ->类信息存储在方法区内(比如类名,继承的类,实现的接口,内部的变量名,方法名,字面量和符号引用)->
      生成class对象,这个对象主要就是用于反射的时候访问类的信息和属性,以及调用类的方法
    - <b>验证,准备,解析</b>
      这三个阶段主要是为了把符号引用转换为直接引用
    - <b>初始化</b>
      对象主要的阶段之一,大部分对象在这里才在堆上分配内存

6. 内存模型 程序计数器的使用场景 没答好
   面试官到底要问内存模型还是内存分区他自己好像都不清楚,我说Java的内存模型主要分为主内存和线程私有内存,他好像对我的话不太认可
   然后我又觉得他可能说的是内存分区
   程序计数器的这个使用场景没答好,正确答案应该是 Java在多线程模型下,由于线程切换带来的影响,为了在切换线程后能够恢复到正确的执行位置,每个线程都持有一个程序计数器

7. 线程的创建有哪些方式，线程池的整体工作流程
   线程的创建方式一共其实有四种:
    - Thread
    - Runnable+Thread
    - callable(实现内部的call方法,这个方法将在futureTask的run方法中使用)+FutureTask(
      这个用于收集callable产生的结果,最终可以调用这个类的get方法得到结果,如果在没有执行完的时候调用,那么会阻塞到任务结束的时候)
      +Thread
    - 线程池, 创建方式, 他问了我类叫啥,确实这个改记一下 ThreadPoolExecutor, 然后拒绝策略没答好,其实一共有四种
      AbortPolicy(直接拒绝,然后报错), DiscardOldestPolicy(丢弃最早的未处理任务), CallerRunsPolicy(
      丢给启动这个线程池的线程来处理), DiscardPolicy(直接丢弃进来的任务,不抛错)
8. innodb索引相关 索引实效 这个没答上真的不应该 比如like查询 没有遵循最左原则
   索引失效这个问题,首先考虑一下什么情况下用不到索引了
    - 找一本书不知道这个本书的名字第一个字是什么,相当于使用like %xxx,和没有符合最左匹配原则
    - 通过索引找比全表扫描更慢,那就没必要用索引了,所以索引就失效了
    - 联表查询会导致索引失效吗?
    - 走索引导致回表可能更慢则不会使用索引
    - 索引列参与了计算,其实可以想想一下为什么这种不行,索引列参与了计算之后,还要进行判断是否与我们指定的值相等,那么我们无法事先知道索引列计算后是否能相等,所以要挨个去计算,相当于全表了
    - or关键字中包含了非索引列
    - 列之间做比较以及索引列进行不等值比较
      其实情况挺多的,没答上来挺可惜

9. 分布式id有哪些生成方式
   UUID,分段式id,雪花算法
10. 为什么uuid不推荐作为主键 没答上
    这个主要是因为uuid不提供自增属性,对于频繁插入数据的情况,会导致innodb的索引重构,性能损耗非常大
11. 数据库自增id有哪些问题 没答好
    - 双主复制的情况下,需要解决两个库之间自增ID的重复问题,可以两边设置不同的自增增量,扩容不便
12. 淘宝的过期未付款的订单处理，整个过程的详细介绍 ：为什么要设计未付款还要等待30分钟 30分钟之后订单又去了哪里 没答上

    符合操作习惯,给足时间确认订单信息再付款,订单占用库存,30分钟过期就归还库存,避免一直占用库存
    - 定时任务定时扫描30分钟内还没有付款的订单,然后直接过期
    - redis客户端监听缓存 todo
    - rocketMQ延迟队列,rabbitMQ死信队列
13. 使用了哪些设计模式

14. 多例模式spring使用什么注解 没答上
    @Scope注解可以设置spring bean的生命周期
15. spring的多数据源主要用到哪些类和注解 没答上
    其实主要使用的类就一个, AbstractRoutingDataSource,主要使用到的方法需要两个
    - afterPropertiesSet(绑定标记和数据源)
    - determineCurrentLookupKey(运行时确定当前线程的数据源标记)
