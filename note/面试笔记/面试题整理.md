[2025Java面试题及答案整理，金三银四面试必备-CSDN博客](https://blog.csdn.net/m0_69632475/article/details/146257828)



# 多线程

1. **什么是多线程，多线程的优劣？**

   多线程（Multithreading）是一种编程和执行模型，允许单个程序内同时运行多个线程，每个线程独立执行任务，共享进程的资源。

   优势：提高响应速度、提升资源利用率、任务并行化、代码结构优化

   劣势：上下文切换开销、资源竞争和同步问题、调试复杂性、内存与cpu开销、平台依赖性

2. **并发编程的优缺点**

   同1优缺点

3. **在 Java 程序中怎么保证多线程的运行安全**

   在Java中保证多线程运行安全的核心是**控制共享资源的访问**，而Java提供了很多实现方法：

   - 同步机制：**`synchronized`关键字**、**`ReentrantLock`（显式锁）**
   - 原子操作（Atomic Classes）
   - 线程封闭：局部变量，**ThreadLocal**
   - 不可变对象
   - 并发工具类
   - 避免共享状态
   - 可见性控制：**`volatile`关键字**
   - 死锁预防

4. **并行和并发有什么区别？**

   **并发**：多个任务在同一时间段**交替**进行（宏观上“同时”运行）。

   **并行**：多个任务在**同一时刻真正同时**运行。

5. **进程与线程的区别?**

   **进程是资源分配的基本单位**；

   **线程是程序执行的最小单位**。

6. **什么是上下文切换?**

   上下文切换（Context Switching）是操作系统在多任务处理时，**保存当前任务状态并恢复另一个任务状态**的核心机制。

7. **什么是线程死锁？**

   死锁发生的四个必要条件(四个条件必须同时满足)

   - 互斥条件：资源一次只能被一个线程占用
   - 占有且等待：线程持有一个资源的同时申请其他资源并且陷入等待。
   - 不可剥夺：线程占有的资源在未使用完之前，不能被强行剥夺。
   - 循环等待：存在一组线程，每个线程都在等待下一个线程持有的资源。

   那么预防死锁的方法就是要破坏掉其中一个条件就可以了，互斥条件是一个必要的条件，所以需要从其他三个条件入手：

   1. 占有且等待：要么**一次性申请所有资源** / 要么**不持有资源就等待**（先释放已持有的）。Java 中使用 `Lock.tryLock()` + 超时控制，不成功就释放已有锁并重试。
   2. 不可剥夺：让资源可以被“强行回收”，或**线程在等待失败后主动释放资源**。
   3. 循环等待：**规定所有资源申请顺序一致**，避免形成环。

8. **守护线程和用户线程有什么区别呢？**
   - 用户线程（User Thread）
     - JVM 会等待所有用户线程执行完毕后才退出。
     - 即使存在守护线程，只要用户线程未结束，JVM 就不会终止。
     - 默认创建的线程都是用户线程，无需额外设置。
   - 守护线程（Daemon Thread）
     - 当所有用户线程结束时，JVM 会直接退出，**无论守护线程是否还在运行**。
     - 守护线程会被强制终止，无法通过 `join()` 或 `wait()` 阻止 JVM 退出。
     - 需通过 `thread.setDaemon(true)` 显式设置，且必须在线程启动前调用，否则抛出 `IllegalThreadStateException`。

9. **说说线程的生命周期及五种基本状态？**

   | 状态名        | 进入方式                    | 离开方式                        |
   | ------------- | --------------------------- | ------------------------------- |
   | NEW           | `new Thread()`              | 调用 `start()` → RUNNABLE       |
   | RUNNABLE      | `start()`、被唤醒           | 被调度执行 / 进入等待或阻塞状态 |
   | BLOCKED       | 等待 `synchronized` 锁      | 获取锁成功后进入 RUNNABLE       |
   | WAITING       | `wait()` / `join()` 等      | 被其他线程唤醒 → RUNNABLE       |
   | TIMED_WAITING | `sleep()` / `wait(time)` 等 | 时间到了或被唤醒 → RUNNABLE     |
   | TERMINATED    | run() 正常退出或异常抛出    | 不可再运行                      |

10. **线程的调度策略**

11. **什么是 Callable 和 Future?**

12. **servlet 是线程安全吗?**

    Servlet并不是线程安全的，设计时应考虑无状态设计。

13. **什么是线程同步和线程互斥，有哪几种实现方式？**

    线程同步：协调多个线程的执行顺序，确保线程按特定的顺序访问资源

    线程互斥：确保同一时间只有一个线程访问共享资源，解决数据竞争的问题

14. **说一下 synchronized 底层实现原理？**



# Spring

## spring ioc 容器的定义

ioc容器主要提供控制反转和依赖注入两个功能，控制反转主要指的是创建对象不再由我们自主来创建，只需要声明对象的创建细节，而创建的过程由spring来完成，依赖注入主要指的是我们代码中需要用到的各种对象之间的依赖关系，由spring进行管理和注入





# Mybatis

## Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？





# Redis

## Redis 持久化数据和缓存怎么做扩容？





# Dubbo

[【硬核】Dubbo常见面试题 - 敖丙 - 博客园](https://www.cnblogs.com/aobing/p/13800058.html)
