公司是一个点餐平台

1. redis数据结构
   字符串,数组,集合,有序集合,哈希表,位图
2. redis过期策略
   对于过期的键,采用两种方式进行删除 1.惰性删除 2.定时删除
3. redis淘汰策略
   淘汰策略是在内存不足是redis删除键时采用的策略,主要包含 1.直接不删除,但是拒绝所有写入 2.删除最少使用的键,这个也分两种,删除过期的或者删除所有的
   3.随机删除,同样的分两种 4.删除最近即将过期的
4. redis与数据库的数据一致性
   1.可以使用消息中间件解决缓存更新失败的问题 2.可以使用canal组件来监控mysql的日志,在缓存更新失败的情况下进行重试
5. rabbitmq消息丢失问题
   这个问题分成三个方面来解析:
    - 消息生产者, 通过发布确认和失败重发的机制确保生产者这一侧的消息一定不会丢失
    - 消息中间件本身, 通过扩展集群,高可用部署的架构来达到中间件本身的消息不丢失
    - 消息的消费侧, 通过手动的消息确认机制和消费失败的重试机制来确保消息一定会被消费
6. spring循环依赖，为什么构造器注入不能解决，有哪些注解可以解决
    - spring通过三级缓存解决循环依赖的问题,默认情况下spring会自动解决循环依赖,但是在高版本中,我们需要通过一个spring.main.allow-circular-references的配置来手动开启
      一级缓存用于保存所有准备完成的依赖,二级缓存用于保存所有ObjectFactory返回的对象,这个对象可能是代理对象也可能是原始对象,
      三级缓存主要用来存储创建对象的工厂对象(用于延迟对象的创建过程,保留整个spring bean的流程统一)  
      关于为什么要用三级缓存,就需要从三级缓存是什么这个说起,从源码看,三级缓存存的是生成对象的一个ObjectFactory,作用是为了延迟对象的生成,在被调用到的地方再生成这个对象
      这里我的理解是,在没有循环依赖的前提下,存在aop的情况下,增强的过程原本应该是在对象创建好,内部依赖填充完整之后进行的.
      然而,存在循环依赖的情况下,如果不添加一个延迟生成对象的三级缓存,那么增强操作将不得不在填充对象之前进行增强,对于整个bean的生成流程的统一性产生了一些不一致
    - 构造器注入不能解决循环依赖的根本原因是,如果使用构造器注入,那么在对象的初始化阶段就需要集齐所有的依赖,然后在循环依赖的前提下,当发生
      a->b->a 的时候,第二次到创建a的过程中会发生a发现自己正在创建中,甚至都没有初始化完成,所以根本就无法创建,会直接报错Cannot
      resolve reference to bean 'bClass' while setting constructor argument
    - 一般来说spring的循环依赖是自动解决的, @Lazy也可以作为解决方案的一种
7. spring cloud有哪些组件

8. 垃圾收集器, 垃圾回收算法以及在哪个阶段会使用这种算法
    - G1 CMS Serial Parallel
    - 主要介绍G1垃圾收集器, G1把内存区域划分为多个大小相等的Region区域,每个区域的角色不是固定的,可能上一次还是新生代,下一次就变成了老年代
    - 标记复制算法一般用于新生代收集, 标记清除和标记整理一般用于老年代
9. mybatis plus组件是否使用
10. mysql数据库隔离级别
    读未提交,读已提交,可重复读,串行化(将杜绝一切并发行为,大量的锁)
11. mvcc的高版本事务是否可以读取到低版本的数据
    读肯定是能读到的,需要确保这个低版本的数据还没有被删除掉
12. linux排查日志