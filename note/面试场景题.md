# 交易系统的交易防重

好的，这个问题很典型，我给你一个**Java交易系统中交易防重（防止重复提交/重复执行）\**的\**实用设计思路**，并举一些常用做法，方便你落地。

------

## 🎯 为什么要做防重

- 用户可能重复点击/重复提交（前端或接口超时）。
- 网络重试/网关超时导致后端收到多次相同请求。
- 第三方回调或补单逻辑重复执行。
- 幂等性保证是金融交易类服务的底线。

------

## ⚙️ 核心原则：唯一请求 + 幂等执行

关键是**识别重复 + 拦截重复 + 保证幂等**，常见思路是：

------

## 1️⃣ 唯一标识：**唯一请求号**

### ✏️ 设计：

- **请求方生成唯一ID**：下单前生成 `requestId` 或 `tradeNo`，前端、客户端或网关生成（UUID、雪花ID、分布式ID等）。
- **服务端生成**：若用户没有传，可以在第一步生成并回写给用户（最好强制由调用方生成，防止漏传）。

------

## 2️⃣ 去重方式

### ✅ **在请求到达前端或服务网关层做幂等 Token**

- 下单前向后端申请一个唯一 Token（比如 Redis 中生成），下单接口消费该 Token，消费成功则执行，消费失败（不存在/已用）则直接拒绝。

**缺点**：Token 需要对所有前端或调用方暴露，稍复杂。

------

### ✅ **在业务服务做幂等键校验**

更常见、简单也更好维护：

1. `requestId` 或 `businessKey`（如：用户ID+业务场景+流水号）唯一。
2. 在数据库插入订单时，加唯一索引，或者在处理表里插入记录时校验唯一键。

示例：

```sql
CREATE UNIQUE INDEX uniq_trade_request ON t_trade (request_id);
```

**特点**：

- 失败时重复插入会抛唯一键冲突。
- 并发下只会有一个成功，其他抛异常或忽略。

------

## 3️⃣ 关键点：**幂等执行**

即使防重了，执行也要幂等：

- 在执行落库或调用下游前，要检查状态是否已处理。
- 比如 `status` 字段，0=待处理，1=成功，2=失败，若已是成功，则不重复执行。

------

## 4️⃣ 技术实现要点（Java示例）

下面是常见的 Java 实现思路：

### ☑️ 方案 1：数据库唯一约束

```java
@Transactional
public void createTrade(TradeRequest request) {
    // 先查是否已存在
    Trade exist = tradeRepository.findByRequestId(request.getRequestId());
    if (exist != null) {
        log.info("重复请求: {}", request.getRequestId());
        return;
    }
    // 写入
    Trade trade = new Trade();
    trade.setRequestId(request.getRequestId());
    trade.setUserId(request.getUserId());
    trade.setStatus("INIT");
    tradeRepository.save(trade);
}
```

### ☑️ 方案 2：Redis 分布式锁

对高并发、写库压力大的，可以：

```java
String lockKey = "trade:lock:" + requestId;
Boolean locked = redisTemplate.opsForValue().setIfAbsent(lockKey, "1", 10, TimeUnit.SECONDS);
if (!locked) {
   // 重复请求
   return;
}
// 正常执行业务
```

**适用场景**：写库量大、唯一索引冲突太多时。

------

## 5️⃣ 注意

✅ 如果是分布式环境，唯一索引是最安全的兜底。
 ✅ 如果是队列消费或回调重复，也需要在消费端幂等（幂等标识可放在消息体里）。

------

## 🧩 总结

👉 交易防重核心是：

| 步骤       | 核心点                   |
| ---------- | ------------------------ |
| 唯一标识   | 有唯一请求ID或流水号     |
| 唯一约束   | 底层有唯一索引或分布式锁 |
| 幂等处理   | 状态字段控制重复执行     |
| 全链路传递 | 请求号必须全链路传递     |

# 如何保证热点账户的并发足够高

好问题！
 热点账户的余额并发修改是**交易系统里最难搞的核心场景**之一，属于典型的**高并发 + 强一致性**问题。

下面我帮你把 **常用的可落地设计方案** 按从“最安全”到“高并发友好”的思路讲清楚，方便你选型或组合用。

------

## ✅ 1️⃣ 最基础方案：数据库行锁（悲观锁）

### 场景

单体、数据量小、QPS不算极端时最安全。

### 做法

```sql
SELECT balance FROM account WHERE account_id = ? FOR UPDATE;
-- 做余额计算
UPDATE account SET balance = ? WHERE account_id = ?;
```

- `FOR UPDATE` 会对这行加行锁。
- 同时只能有一个事务修改，强一致性保证。
- 不会出现超额扣款、并发丢失。

### 缺点

- 并发高时锁竞争严重，TPS上不去。
- 高并发下容易死锁或阻塞。

------

## ✅ 2️⃣ 乐观锁（版本号 CAS）

### 场景

并发比悲观锁高，但需要业务允许失败重试。

### 做法

表设计：

```sql
account(id, balance, version)
```

流程：

1. 先读 `balance` 和 `version`。

2. 扣减后用：

   ```sql
   UPDATE account SET balance = ?, version = version + 1 WHERE id = ? AND version = ?;
   ```

3. 如果返回行数 = 0，则表示版本冲突，重试。

Java 伪代码：

```java
while (true) {
    Account account = accountMapper.selectById(id);
    int updated = accountMapper.updateBalance(id, newBalance, account.getVersion());
    if (updated > 0) {
        break;
    }
    // 版本冲突，重试
}
```

### 缺点

- 重试成本高，冲突多时性能反而低。
- 对写热点高的账户（比如单个大账户、分账账户），冲突严重时依旧是瓶颈。

------

## ✅ 3️⃣ 分段账户（账户分片）

### 场景

**单个账户本身就是热点，但可以业务拆分**。

思路：

- 把一个逻辑账户拆成多条物理账户，按时间/地域/分库分表。
- 比如一个商户余额拆成按月分表结算，或者按币种/账户类型拆分。

适合：

- 聚合账户、大商户。
- 平台结算账户。

------

## ✅ 4️⃣ 加入分布式锁（Redis/Redisson）

### 场景

数据库锁或乐观锁冲突太严重时，用分布式锁保护热点账户。

做法：

- 给单个账户上锁：

  ```java
  RLock lock = redissonClient.getLock("balance:lock:" + accountId);
  lock.lock();
  try {
     // 查询余额，扣减
  } finally {
     lock.unlock();
  }
  ```

特点：

- 锁粒度是账户ID，只有同账户冲突。
- 不同账户可并发。

缺点：

- Redis 本身需保证高可用，否则锁丢失风险需要仔细兜底。
- 性能瓶颈在 Redis，如果极端热点账户，锁争用还是大。

------

## ✅ 5️⃣ 队列化/单线程串行化

### 场景

极端热点账户（如一个公共钱包），银行大多用这套。

做法：

- 所有对同一账户的修改请求写入消息队列。
- 用单线程或分区有序消费，按顺序串行处理。

优势：

- 不存在并发写冲突，天然一致。
- 高并发下也可水平扩展。

缺点：

- 延迟比纯内存并发高一些（但可以做到毫秒级）。
- 复杂度在消息可靠性和消费可用性。

------

## ✅ 6️⃣ 内存账本 + 定时对账（极致高并发场景）

比如高频撮合撮交易所常用：

- 余额扣减在撮合引擎里是内存账本，直接内存原子操作（如 LongAdder/AtomicLong）。
- 定时把余额落库或者批量刷写。
- 落库失败或异常崩溃用双写 WAL（Write Ahead Log）恢复。

特点：

- 极致低延迟，高并发。
- 对一致性和对账要求极高，需要有 WAL + 审计对账。

------

## 🚀 实战组合推荐

| 并发量              | 典型适配                       |
| ------------------- | ------------------------------ |
| 低并发账户          | `SELECT FOR UPDATE` 或唯一索引 |
| 并发中等            | 乐观锁                         |
| 并发高 + 账户热点高 | 分布式锁 + 乐观锁              |
| 极端热点账户        | 单账户队列串行化               |
| 高频撮合            | 内存账本 + WAL                 |

------

## 🧩 关键点

✅ 并发控制是手段，最核心是保证**资金一致性**。
 ✅ 只要设计了“最终写唯一、串行化落库”，再高并发都能兜住。
 ✅ 实时性 vs 一致性，有时需要在架构层做分层（如撮合引擎和账户账本分离）。

------

