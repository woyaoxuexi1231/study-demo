## 基础

### RabbitMQ 概念里的 channel、exchange 和 queue 这些是逻辑概念，还是对应着进程实体？这些别起什么作用？

在 RabbitMQ 中，channel、exchange 和 queue 是逻辑概念，它们各自扮演不同的角色：

- **Channel（通道）**

  Channel 是在客户端和 RabbitMQ 之间建立的虚拟连接，用于建立和管理 Exchange 和 Queue，以及在它们之间传递消息。
  每一个客户端连接到RabbitMQ服务器底层实际上是建立了一个TCP连接，而信道是建立在这个连接上的虚拟连接。
  Channel 是实际进行路由工作的实体，即负责按照 routing_key 将 message 投递给 queue。

- **Exchange（交换机）**

  Exchange 是消息交换机，接收生产者发送的消息并根据路由规则将消息分发到一个或多个队列。
  RabbitMQ 提供了四种类型的 Exchange：Direct、Topic、Fanout 和 Headers。
  Exchange 根据什么规则把消息投递到哪些 queue 中？这取决于 Exchange 的类型以及使用的 路由规则。

- **Queue（队列）**

  Queue 是消息在 RabbitMQ 中的存储区，它接收 Exchange 路由过来的消息，并将其存储起来，等待消费者来消费。
  Queue 可以绑定多个 Exchange，也可以由多个消费者来消费。
  在 Queue 中，消息遵循先进先出（FIFO）的原则。Queue 具有自己的 erlang 进程。

这些概念都是 RabbitMQ 中的核心组件，它们共同协调以实现消息的生产、路由和消费。

### RabbitMQ 中的 broker 和 cluster

在 RabbitMQ 中，"Broker" 和 "Cluster" 的概念是核心组成部分，赋予系统高效处理消息的能力：

**Broker** 负责消息传递的管理和中介。简而言之，它是一个服务器实体，或者服务点，负责接收生产者的消息，并将这些消息路由到一个或多个目的地（即队列）。消费者从这些队列中接收消息来进行处理。

主要功能和职责包括：

- **消息接收与转发**：Broker 接收来自生产者的消息并根据路由规则转发到正确的队列。
- **队列管理**：管理消息队列，维护消息直到它被消费。
- **支持交换机（Exchanges）**：交换机处理消息的路由逻辑，根据一定的规则将消息从生产者推送到一个或多个队列。
- **事务和安全性**：确保消息传递的安全性和可能的事务支持。
- **性能监测和调优**：提供工具和接口监控消息流和性能。

**Cluster** 指的是多个RabbitMQ服务器（或节点）的集合，它们共同工作，提供单一逻辑Broker的视角。集群的目的是提高系统的可用性、扩展性和负载均衡。

集群的主要特点包括：

- **资源共享**：节点间共享队列、交换器等配置，使得任何节点都能处理来自客户端的请求。
- **高可用性**：通过部署多个节点，可以在一个节点失败的情况下，由其他节点继续处理消息，增加系统的健壮性。
- **负载均衡**：集群可以均衡处理客户端的连接和消息流量，提高处理能力和响应速度。
- **灵活扩展**：随着需求的增长，可以透明地向集群添加更多的节点，以增强其处理能力。

简而言之，Broker是处理和维护消息的具体实体，而Cluster使多个Brokers能够高效、可靠地协同工作，确保服务的高可用性和扩展需求。

## 高可用

### RabbitMQ集群介绍

RabbitMQ集群具有以下特点：

1. **高可用和负载均衡**：当单台RabbitMQ服务处理消息的能力到达瓶颈时，可以通过集群来实现高可用和负载均衡¹。

2. **节点类型**：在RabbitMQ集群中，节点类型可以分为两种：内存节点和磁盘节点¹。

3. **集群模式**：RabbitMQ中的集群主要有两种模式：普通集群模式和镜像队列模式¹。

4. **数据同步**：在普通集群模式下，集群中各个节点之间只会相互同步元数据，也就是说，消息数据不会被同步¹。而在镜像队列模式下，节点之间不仅仅会同步元数据，消息内容也会在镜像节点间同步，可用性更高¹。

5. **高可用集群**：可以通过Keepalived和HAProxy两个组件实现了集群的高可用性和负载均衡功能²。

6. **多活模式**：这种模式需要依赖rabbitmq的federation插件，可以实现继续的可靠AMQP数据通信²。

7. **元数据共享**：集群节点之间共享元数据，不共享队列数据 (默认)⁴。

8. **数据互相转发**：RabbitMQ节点数据互相转发，客户端通过单一节点可以访问所有数据⁴。

RabbitMQ集群并非能保证消息万无一失,即使消息,队列,交换机等都设置为可持久化,客户端和服务端也都正确的使用了确认方式.当集群中的一个rabbitMQ节点崩溃时,该节点上所有的消息也会丢失.rabbitMQ集群中的所有节点会同步和备份所有的元数据信息.

在RabbitMQ中，"元数据"主要指的是以下几种信息¹³：

1. **队列元数据**：包括队列名称和它的属性³。
2. **交换器元数据**：包括交换器名称、类型和属性³。
3. **绑定元数据**：一张简单的表格展示了如何将消息路由到队列³。
4. **vhost元数据**：为vhost内的队列、交换器和绑定提供命名空间和安全属性³。

因此，当用户访问其中任何一个RabbitMQ节点时，通过rabbitmqctl查询到的queue／user／exchange/vhost等信息都是相同的³。这就是RabbitMQ在普通模式下同步元数据的含义。

### 普通集群模式

- **在普通集群下,同一个队列只要一个节点创建之后,其他节点就不会重复创建了吗?**  
  在RabbitMQ集群中，当一个队列在某个节点（例如node1）上被创建后，这个队列的元数据（包括队列名称、属性等）会被同步到集群中的所有其他节点（例如node2）¹²。因此，即使你在node2上尝试创建同名的队列，RabbitMQ会识别出这个队列已经存在，因此不会重复创建¹²。
  然而，需要注意的是，虽然队列的元数据在集群中的所有节点上都是可用的，但在普通模式下，队列中的消息数据是不会在节点之间同步的¹²。也就是说，如果一个消息被发布到node1上的队列，那么这个消息默认情况下只存在于node1上，除非有消费者从node2上消费这个队列，这时node2会从node1拉取消息¹²。
- **我现在有一个node1和node2的rabbitmq集群. 有一个test交换机, 我在node2上面创建了一个test的queue的队列,
  我在node1往test上面发消息,node2的queue队列上的消费者能收到消息吗?**  
  是的，node2上的消费者可以收到消息。在RabbitMQ集群中，交换器（Exchange）的元数据是在所有节点上同步的¹。当你在node1上向test交换器发送消息时，RabbitMQ会根据交换器的路由规则将消息路由到相应的队列¹。即使队列是在node2上创建的，消息仍然可以被路由到那里¹。
  然后，node2上的消费者可以从该队列中获取并消费这些消息¹。这是因为消费者和队列之间的交互是在队列所在的节点上进行的¹。
  所以，即使你在node1上发布消息，只要消息被路由到node2上的队列，node2上的消费者就可以收到这些消息¹。
    - 如果此时node2发生宕机:
        1. **队列将不可用,队列的状态会变成down**
        2. **新的服务会因为队列的状态而无法启动**,服务会报错channel error; protocol method: #method<channel.close>(reply-code=404,
           reply-text=NOT_FOUND - home node '
           rabbit@node-129' of durable queue 'topic-queue-slave' in vhost '/' is down or inaccessible, class-id=50,
           method-id=10)
        3. **消息生产者的消息将变得不可达,在到达交换机之后将被丢弃**
    - node2重启后,队列恢复可用
    - 如果node2是内存节点
        1. 那么这个节点上的所有信息都将丢失,如果信息是持久化的,那么节点重启后是可以恢复的(包括队列内的消息)
        2. 如果队列信息是非持久化的,那么node宕机后,数据都将丢失,但是其他节点就可以重新声明这个队列了

### 镜像队列

RabbitMQ 的镜像队列是一种高可用性和可靠性的队列模式。镜像队列通过在多个 RabbitMQ
节点之间复制队列的消息，确保即使其中一个节点失效，消息仍然可以被其他节点处理。具体来说，镜像队列会将队列中的消息同步到多个节点上，每个节点都会保存队列的完整副本。这样，即使某个节点发生故障，其他节点上的消息仍然可以被消费，从而保证了消息队列的高可用性和可靠性。

镜像队列主要涉及以下几个概念和特性：

1. **镜像队列：** 由多个节点上的相同队列组成，每个节点都保存着队列的完整副本。
2. **节点同步：** 队列中的消息会在多个节点之间同步，确保每个节点都有相同的消息副本。
3. **故障转移：** 如果某个节点失效，RabbitMQ 会自动将消息路由到其他节点上的队列中，保证消息的可靠性和不丢失。
4. **高可用性：** 镜像队列提供了数据的冗余存储，确保即使节点故障，系统仍然可以继续提供服务，保证了消息队列的高可用性。

总的来说，镜像队列是 RabbitMQ 提供的一种高可靠性的消息队列模式，适用于需要保证消息不丢失并且能够在节点故障时自动切换的应用场景。

当RabbitMQ的镜像队列的拥有节点（也就是master节点）宕机后，RabbitMQ会进行以下操作¹²：

1. **选举新的master节点**：RabbitMQ会从剩余的slave节点中选举一个最老的节点作为新的master节点¹。这是因为最老的slave节点与前任master节点之间的同步状态应该是最好的¹。RabbitMQ
   会自动将队列的控制权转移到这个新的master节点

2. **处理未同步的消息**：如果所有的slave节点都处于未同步状态，那么前任master节点中未被同步的消息将会丢失¹。

3. **重新入队所有unack的消息**
   ：新的master节点会重新入队所有unack的消息¹。这是因为新的slave节点无法区分这些unack的消息是否已经到达客户端，或者是ack信息丢失在旧的master节点链路上，再或者是丢失在旧的master节点组播ack消息到所有slave节点的链路上¹。所以出于消息可靠性的考虑，重新入队所有unack的消息，不过此时客户端可能会有重复消息¹。

4. **处理客户端连接**：如果客户端连接着slave，并且Basic.Consume消费时指定了x-cancel-on-ha-failover参数，那么断开之时客户端会收到一个Consumer Cancellation
   Notification的通知，消费者客户端中会回调Consumer接口的handleCancel方法¹。如果未指定x-cancel-on-ha-failover参数，那么消费者将无法感知master节点宕机¹。

5. **处理主动停止的master节点**：当所有slave节点都出现未同步状态，并且ha-promote-on-shutdown设置为when-synced (默认)
   时，如果master节点因为主动原因停掉，比如通过rabbitmqctl
   stop命令或者优雅关闭操作系统，那么slave节点不会接管master节点，也就是此时镜像队列不可用¹。但是如果master节点因为被动原因停掉，比如Erlang虚拟机或者操作系统崩溃，那么slave节点会接管master节点¹。

6. **原来的master节点恢复之后**: 根绝ha-mode的模式,会选择是否加入镜像队列

## 奇奇怪怪的问题

### 能够在地理上分开的不同数据中心使用 RabbitMQ cluster 吗? TODO

在 RabbitMQ 中，通常建议将 Cluster
中的节点部署在相同数据中心或在物理上接近的位置，这是为了确保节点之间的通信延迟尽可能低，从而保持集群的整体性能和稳定性。节点之间需要频繁地交换心跳、状态信息和数据同步，如果延迟较高，可能会影响消息的及时传递和集群的健康状况。

然而，如果有跨地理位置的需求，比如在不同的数据中心部署节点以实现灾难恢复和高可用性，可以考虑以下几种策略：

1. Federation
   使用 RabbitMQ 的 Federation 插件可以在不同的 RabbitMQ Broker 或集群之间进行消息传递。这不是真正意义上的集群，而是一个松耦合的结构，允许单独部署在不同地理位置的多个 Broker
   之间异步地复制消息流。这适用于将数据复制到远程位置，但不保证实时性和事务性。

2. Shovel
   另一个选项是使用 RabbitMQ 的 Shovel 插件，这可以看作是 Federation 的一种更简单、更低层次的形式。它用于在不同的 Broker 之间可靠地传输消息。Shovel 可以配置为将特定队列中的消息推送到远程
   Broker 的队列中。

3. 多站点集群
   虽然不推荐，但技术上可以设置跨数据中心的 RabbitMQ 集群。这会涉及到一些网络优化和配置，如增强心跳监测、调整超时设置、使用专有网络连接等，以降低跨站点通信的影响。这种配置的复杂性和维护成本较高，通常需要高级的网络技术支持。

4. 第三方解决方案
   可以考虑使用如 Kubernetes 等容器管理工具，通过服务网格技术管理和优化跨数据中心的通信。或者使用第三方同步和复制解决方案来实现跨数据中心的消息同步。

总结，虽然可以在不同数据中心间使用 RabbitMQ，但官方通常推荐使用 Federation 或 Shovel 这样的插件，以便在多个独立的 RabbitMQ
实例或集群之间进行消息传输，而不是建立一个跨地理位置的紧密耦合集群。这样可以在保持地理分布的灵活性的同时，避免由于高延迟和网络不稳定带来的潜在问题。

### 为什么 heavy RPC 的使用场景下不建议采用 disk node

在 RabbitMQ 中，节点可以配置为 **disk node** 或 **ram node**。在处理重型远程过程调用 (RPC) 场景时，不建议使用 disk node 的原因主要与性能和响应速度有关。以下是这种推荐的背景和原理：

#### Disk Node 和 RAM Node 的区别：

1. **Disk Node**：在这种节点中，所有消息队列的元数据以及持久化消息都存储在磁盘中。这种配置提供了更强的数据持久性，但磁盘 I/O 操作相对较慢，尤其是在高负载和高频请求的环境下。
2. **RAM Node**：在 RAM node 中，消息和队列的元数据存储在内存中。虽然持久化消息仍需写入磁盘，元数据操作和非持久消息的处理速度更快，因为内存访问速度远高于磁盘。

#### 为何在 RPC 场景下推荐使用 RAM Node：

- **响应速度**：RPC 调用通常需要快速响应，因为它们常常是客户端和服务器之间同步通信的一部分。使用 RAM node 可以减少延迟时间，因为内存中的数据访问速度比磁盘快得多。
- **高并发支持**：在高负载的 RPC 系统中，可能会有大量的并发请求和消息传递。RAM nodes 由于其快速的数据处理能力，更适合处理这种高并发环境。
- **减少磁盘 I/O 压力**：频繁的 RPC 调用可能导致大量的磁盘 I/O 操作，这对于 disk nodes 来说可能是一个瓶颈，因为每次消息传递都可能涉及到磁盘操作。相比之下，RAM nodes
  在处理这些操作时可以显著减轻对磁盘的依赖。

#### 考虑因素

尽管 RAM nodes
提供了更好的性能，但它们在系统崩溃后恢复数据的能力较弱，因为不是所有数据都写入磁盘。因此，在设计系统时，需要权衡性能和数据持久性之间的需求。对于确保数据不丢失至关重要的系统，可能需要通过其他机制（如频繁同步到磁盘或使用持久化队列配置）来补充内存节点的使用。

总体而言，在重型 RPC 场景中，推荐使用 RAM node 是出于性能和系统响应能力的考虑，尤其是在高负载和要求低延迟的应用场景中。

### 什么是 Blackholed,什么情况下会发生,怎么避免?

"Blackholed"通常不是 RabbitMQ 官方术语，但这个概念或短语可能被用来描述一种情况，即消息被发送到一个队列中，但这些消息似乎消失了，好像黑洞一样，没有被消费或者没有任何处理的迹象。这种情况可能由几种不同的原因引起：

#### 导致消息 “Blackholed” 的常见原因：

1. **配置错误**：
    - 队列没有正确的消费者或者消费者没有正确启动。
    - 交换机和队列之间的绑定可能没有正确设置，导致消息没有路由到预期的队列。
    - 使用了错误的交换机类型，导致消息的路由不符合预期。

2. **资源限制**：
    - 如果队列达到其大小限制（由最大长度或者内存/磁盘限制定义），进一步的消息可能会被丢弃或者替换。
    - 系统资源不足，如 CPU 或内存过载，可能导致消费者处理速度不够快，无法及时清空队列。

3. **权限问题**：
    - 发布者或消费者可能没有足够的权限访问特定的交换机、队列或消息。

4. **网络问题**：
    - 分布式部署中的网络问题可能导致节点间的通信故障，影响消息的正常流动。

#### 避免消息 “Blackholed” 的策略：

1. **正确配置验证**：
    - 确保所有的交换机、队列和绑定都按预期配置，并且交换机、队列和路由键的名称正确无误。
    - 检查并确保消费者正常运行，并且能够连续从队列中取出消息。

2. **资源监控和管理**：
    - 监控 RabbitMQ 实例的资源使用情况（如 CPU、内存和磁盘使用情况），必要时增加资源或优化现有资源的使用。
    - 配置合适的队列长度和消息持久化策略，以防队列填满导致消息丢失。

3. **安全和权限配置**：
    - 确保所有用户和应用都具有适当的权限进行消息的发布和消费。
    - 定期审查和更新安全策略，确保符合当前的访问控制需求。

4. **网络连通性确保**：
    - 在分布式环境中，确保所有节点间的网络连接是稳定和高效的。
    - 使用心跳和其他机制来监控网络健康状况，及时发现并解决网络问题。

通过遵循这些策略，可以最大限度地减少或避免因配置错误、资源限制、权限问题或网络问题而导致的消息“黑洞”现象。

### RabbitMQ 中的 cluster、mirrored queue 以及 warrens 机制分别用于解决什么问题?存在哪些问题?

在 RabbitMQ 中，cluster、mirrored queue 和 warrens 机制都是用于解决高可用性和可靠性方面的问题，但它们的应用场景和解决方式略有不同：

1. **Cluster（集群）**：
    - **作用**：RabbitMQ 集群允许将多个节点组合在一起，以提高系统的可用性和性能。集群中的节点可以相互通信和共享消息，从而提供高可用性、负载均衡和故障容错等功能。
    - **解决的问题**：集群能够解决单点故障的问题，即使其中一个节点出现故障，整个系统仍然可以继续运行。
    - **存在的问题**：集群配置复杂，需要考虑节点之间的通信、数据同步、负载均衡等方面的问题，同时也需要考虑集群中可能出现的分区问题以及数据一致性等方面的挑战。

2. **Mirrored Queue（镜像队列）**：
    - **作用**：镜像队列允许在多个节点之间复制和同步队列中的消息，从而确保即使其中一个节点出现故障，消息仍然可以被其他节点接收和处理。
    - **解决的问题**：镜像队列解决了单点故障的问题，提高了消息的可靠性和可用性。
    - **存在的问题**：镜像队列会增加系统的负载和网络流量，特别是在消息量较大的情况下，需要考虑网络带宽和性能方面的限制。

3. **Warrens 机制**：
    - **作用**：Warrens 是 RabbitMQ 3.8 版本引入的一种新的分区容错机制，它可以帮助集群中的节点在网络分区时保持数据一致性，并尽可能地减少数据丢失的风险。
    - **解决的问题**：Warrens 机制主要解决了集群中可能出现的网络分区问题，确保分区后各个节点之间的数据同步和一致性。
    - **存在的问题**：Warrens 机制相对较新，可能存在一些实现上的挑战和性能方面的限制，需要在实际应用中进行充分的测试和评估。

综上所述，RabbitMQ 中的 cluster、mirrored queue 和 warrens
机制都是为了提高系统的可用性和可靠性而设计的，但在实际应用中需要根据具体的场景和需求来选择合适的解决方案，并注意它们可能存在的一些问题和限制。

### 消息重复消费的解决方案

### 消息幂等性(需要业务代码具备这种幂等性操作)

### 消息的有序性(单一消费者模式,kafka分区顺序,RocketMQ顺序消息队列)

### 关于spring配置集群的问题

像这样配置多个地址
spring.rabbitmq.addresses=192.168.80.128:5672,192.168.80.129:5672

提供了多个地址，那么 Spring Boot 会尝试按照你提供的顺序去连接这些地址。也就是说，如果第一个地址的 RabbitMQ 服务器无法连接，那么 Spring Boot 会尝试连接第二个地址，以此类推。

但是，需要注意的是，这并不意味着 Spring Boot 会与所有的 RabbitMQ 服务器建立连接。实际上，Spring Boot 只会与能够成功连接的第一个 RabbitMQ 服务器建立连接。如果这个连接断开，Spring Boot
会再次尝试按照你提供的顺序去连接这些地址。

## rabbimq自带工具

这些工具是 RabbitMQ 的管理工具，用于执行各种管理和维护任务。下面是每个工具的简要说明：

1. **rabbitmqctl**：RabbitMQ 控制工具，用于执行各种 RabbitMQ 命令，如启动、停止、重启节点，创建和删除队列、交换机等，管理用户、权限和策略等。

2. **rabbitmq-defaults**：RabbitMQ 默认配置文件，包含 RabbitMQ 启动时的默认配置参数。通常不需要手动编辑此文件，而是通过配置文件（如 rabbitmq.config）进行自定义配置。

3. **rabbitmq-diagnostics**：RabbitMQ 诊断工具，用于执行各种诊断命令，如检查 RabbitMQ 节点状态、性能指标、日志文件、插件信息等，用于故障排除和性能优化。

4. **rabbitmq-env**：RabbitMQ 环境变量设置脚本，用于设置 RabbitMQ 启动时的环境变量，如 JAVA_HOME、ERLANG_HOME 等。

5. **rabbitmq-plugins**：RabbitMQ 插件管理工具，用于启用、禁用、列出和查找 RabbitMQ 插件，以扩展 RabbitMQ 的功能。

6. **rabbitmq-queues**：RabbitMQ 队列管理工具，用于执行队列相关的管理任务，如查看队列状态、清除队列消息、移除队列等。

7. **rabbitmq-server**：RabbitMQ 服务器启动脚本，用于启动 RabbitMQ 服务器节点。

8. **rabbitmq-upgrade**：RabbitMQ 升级工具，用于执行 RabbitMQ 升级任务，如升级 RabbitMQ 节点的版本、插件等。

这些工具是 RabbitMQ 管理和维护的核心工具，通过它们可以进行各种操作，确保 RabbitMQ 集群的正常运行和管理。

## rabbitMQ Queue 管理界面

![这是图片](队列详情.png)

这个队列的参数解释如下：

- **Features**：列出了队列的功能配置。在这个队列中，已经配置了死信交换机（Dead Letter Exchange）为 "exchange-test-dead"，并且队列是持久化的。

- **Policy**：显示了应用于队列的策略。在这个例子中，策略为 "mirror_queue"，表示这是一个镜像队列。

- **Effective policy definition**：显示了应用到队列的有效策略定义。ha-mode 设置为 "exactly"，ha-params 设置为 "2"，ha-sync-mode 设置为 "automatic"
  。这表示队列采用确切的高可用性模式，有两个镜像节点，并且采用自动同步模式。

  在RabbitMQ中，`ha-mode`是指高可用模式（High Availability Mode），它是通过镜像队列（Mirrored Queues）来实现的¹。`ha-mode`有两种主要的模式：
    1. **all**：在这种模式下，队列会在所有的节点上进行镜像³⁴。这意味着，如果你的RabbitMQ集群有5个节点，那么每个队列都会在这5个节点上都有一个副本。
    2. **exactly**：这种模式允许你指定具体的镜像数量。例如，你可以设置`ha-params`为3，那么RabbitMQ会确保每个队列在集群中有3个副本¹。

  此外，还有一个`ha-sync-mode`参数，它决定了新的镜像节点加入时，数据是如何同步的¹。它有两种模式：

    1. **automatic**：新的镜像节点加入时，队列会自动进行同步¹。
    2. **manual**：需要手动触发同步¹。

  需要注意的是，RabbitMQ的镜像队列已经被标记为过时，并计划在RabbitMQ 4.0中移除¹。RabbitMQ建议使用Quorum
  Queues或者Streams来替代镜像队列¹。这两种新的队列类型都支持数据复制，而且相比于镜像队列，它们提供了更高的吞吐量和更稳定的延迟¹。

- **Node**：指定了队列所在的节点。在这里，队列位于节点 "rabbit@node-129" 上。

- **Mirrors**：指定了队列的镜像节点。在这里，队列的镜像节点是 "rabbit@node-128"。

- **State**：显示了队列的状态。在这里，队列状态为 "idle"，表示没有消息等待处理。

- **Consumers**：显示了当前消费者的数量。在这里，没有消费者，因此为0。

- **Consumer capacity**：显示了消费者容量。在这里，为0%，表示消费者容量尚未被使用。

- **Total, Ready, Unacked, In memory, Persistent, Transient, Paged Out**：显示了不同状态下消息的数量。在这里，所有这些数字都为0，表示队列中没有消息。
  这些参数是 RabbitMQ 管理界面中队列的各种状态指标，它们表示了队列当前的消息状态和存储情况：
    1. **Total**：
        - 表示队列中消息的总数量，包括就绪状态、未被确认的状态以及已被消费但未被删除的状态。

    2. **Ready**：
        - 表示队列中处于就绪状态的消息数量，即可以立即被消费的消息数量。
        - 这些消息已经被 RabbitMQ 接受，并且等待着被消费者取走。

    3. **Unacked**：
        - 表示队列中处于未被确认状态的消息数量，即已经被消费者取走但还未收到确认的消息数量。
        - 这些消息已经被消费者接收，但尚未发送确认消息给 RabbitMQ。

    4. **In memory**：
        - 表示队列中当前存储在内存中的消息数量。
        - 这些消息通常是就绪状态的消息，等待着被消费者取走。

    5. **Persistent**：
        - 表示队列中当前存储在磁盘上的持久化消息数量。
        - 这些消息通常是已经被消费者取走但尚未被删除的消息，或者是消息发送时被标记为持久化的消息。

    6. **Transient**：
        - 表示队列中当前存储在内存中的非持久化消息数量。
        - 这些消息通常是就绪状态的消息，但由于内存有限，可能会被转移到磁盘上以释放内存空间。

    7. **Paged Out**：
        - 表示队列中当前存储在磁盘上的非持久化消息数量。
        - 这些消息通常是就绪状态的消息，但由于内存不足，被移动到了磁盘上。
- **Messages，Message body bytes，Process memory**
  这些参数是关于队列消息和内存占用的指标：
    1. **Messages**：
        - 表示队列中消息的总数量，包括就绪状态、未被确认的状态以及已被消费但未被删除的状态。

    2. **Message body bytes**：
        - 表示队列中所有消息体的总字节数。
        - 这个指标反映了队列中所有消息内容的总大小。

    3. **Process memory**：
        - 表示队列所占用的进程内存大小，即队列所在节点上的 Erlang 进程的内存使用情况。
        - 这个指标反映了队列所在节点上 RabbitMQ 进程的内存占用情况。
