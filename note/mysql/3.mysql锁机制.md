# 开篇：了解 MySQL 的锁机制吗,谈谈你的理解

从这三个方面来了解锁

1. 锁是什么?为了解决什么?
2. 有哪些锁?
3. 锁相关的其他东西

## 锁本身

### 锁到底是什么

MySQL中的锁是一个用于控制多个用户或进程访问同一数据库资源的机制。锁的主要目的是确保数据的完整性和一致性，特别是在多个用户或事务同时操作数据库时。MySQL锁的关键用途和目的包括：

#### 1. 保证数据一致性

锁机制确保在任何给定时间，只有允许的操作能够访问或修改数据。这帮助防止数据在未完成写操作的情况下被读取（称为“脏读”），或者未提交的数据被其他事务读到（称为“不可重复读”和“幻读”）。

#### 2. 防止更新冲突

当多个事务试图同时更新同一数据时，锁可以序列化访问，确保每个事务的更改不会与其他事务冲突，从而防止数据损坏和保证操作的原子性。

#### 3. 提高并发性能

通过合理利用不同类型和粒度的锁，MySQL可以在保障数据一致性和完整性的同时，优化系统的并发性能。例如，通过行级锁而非表级锁，可以减少资源竞争，使更多的用户或进程能够同时高效地工作。

#### 4. 支持不同的事务隔离级别

MySQL根据标准SQL定义提供了不同的事务隔离级别（读未提交、读提交、可重复读和串行化）。这些隔离级别通过使用不同的锁策略（如读锁、写锁、间隙锁等）来实现，以此来平衡并发性和数据正确性之间的需求。

#### 5. 事务管理

在事务处理中，锁是管理和保证事务ACID属性（原子性、一致性、隔离性、持久性）的关键工具。锁有助于确保事务要么完全执行，要么完全不执行，同时确保事务的结果即使在系统出错的情况下也能持久保存。

总结来说，MySQL中的锁是为了管理数据库中的并发操作，确保数据的一致性和完整性，同时也支撑事务的安全和有效执行。锁的设计和实现对数据库系统的性能和可靠性有直接影响。

### 以不同的维度了解锁

InnoDB是一个支持事务的存储引擎，提供高并发和事务完整性。了解不同维度的锁类型有助于更好地设计和优化数据库应用。以下是从几个不同的维度概述InnoDB的锁类型：

#### 1. 锁的粒度

- **行级锁**：最细的锁粒度，只锁定被直接访问的数据行。优势在于并发性高，但管理这些锁的成本也较高。
- **表级锁**：粗粒度锁，当操作涉及大量数据或全表操作时，可能会锁定整个表。表级锁执行速度快，但并发性较差。
- **间隙锁（Gap Locks）**：锁定一个范围内的空间，不仅涉及具体的行，还包括行之间的“间隙”。这种锁主要用于防止幻读。

#### 2. 锁的模式

- **共享锁（S Lock）**：允许一个事务读取一行，并防止其他事务获得相同数据行的排他锁。
- **排他锁（X Lock）**：允许事务更新或删除一行，并防止其他事务读取或修改同一行。
- **意向锁**：属于表级锁，分为意向共享锁（IS Lock）和意向排他锁（IX Lock），声明事务将要在表的行上请求共享锁或排他锁。

#### 3. 锁的目的

- **记录锁**：直接锁定目标记录。
- **间隙锁**：锁定一个范围内的记录，但不包括记录本身。用于保证读取的一致性和防止幻读。
- **临键锁（Next-Key Locks）**：是记录锁和间隙锁的组合，锁定一条记录及其前面的间隙，常用于范围查询的场景。

#### 4. 锁的功能

- **防止更新冲突**：通过排他锁确保一行数据在修改期间不被其他事务修改。
- **保持数据一致性**：使用共享锁和排他锁确保在事务处理过程中数据的读取和修改不会受到干扰。
- **防止幻读**：间隙锁和临键锁帮助实现可重复读的隔离级别，防止事务期间新的记录插入到结果集中。

通过这些不同维度的锁类型，InnoDB能够提供灵活且强大的数据处理能力，适用于要求高并发和高事务完整性的应用场景。理解并正确使用这些锁对于优化数据库性能和事务处理至关重要。

### 行锁的三种算法

MySQL的InnoDB存储引擎支持三种行锁算法：

1. **Record Lock**：单个行记录上的锁。这种锁会锁住具体的索引项。当SQL执行按照唯一性索引进行数据的检索时，查询条件等值匹配且查询的数据是存在，这时SQL语句加上的锁即为记录锁Record
   locks，锁住具体的索引项。

2. **Gap Lock**：间隙锁，锁定一个范围，但不包含记录本身。这种锁主要用于防止幻读。

3. **Next-Key Lock**：Record Lock + Gap Lock，锁定一个范围，并且锁定记录本身。Next-Key Lock是结合了Gap Lock和Record Lock的一种锁定算法，在Next-Key
   Lock算法下，InnoDB对于行的查询都是采用这种锁定算法。

这三种锁算法的选择取决于具体的操作和索引类型。例如，当我们查询的索引含有唯一属性时，Next-Key Lock会进行优化，降级为Record
Lock，也就是说锁住的仅仅是索引本身，而不是范围。这样可以提高并发能力，但是可能会导致幻读问题。因此，具体使用哪种锁算法，需要根据实际的业务需求和系统性能来决定。

## 锁相关的其他东西

### 快照读和当前读

快照读（Snapshot Read）和当前读（Current Read）是数据库中常用的两种读取数据的方式，这两者主要探讨读取的数据版本问题。

1. **快照读（Snapshot Read）**：
    - 快照读是在事务开始时创建一个数据快照，并在整个事务过程中使用该快照来读取数据。换句话说，在事务执行期间，快照读始终读取事务开始时数据库中的数据状态。
    - 快照读可以保证事务在读取数据时不会受到其他事务的影响，即使其他事务在事务执行期间对数据进行了修改，也不会影响到快照读取的数据。

2. **当前读（Current Read）**：
    - 当前读是在执行读取操作时直接读取数据库中当前的数据状态。换句话说，当前读不会创建数据快照，而是直接读取数据库中最新的数据。
    - 当前读对于一些需要读取最新数据的场景非常有用，例如需要读取实时更新的数据或者执行短期操作的事务。

在 MySQL 中，根据使用的 SQL 语句不同，可以选择使用快照读或当前读：

- 当执行 `SELECT` 查询语句时，默认情况下使用的是快照读，即事务开始时读取的是快照而不受其他事务影响。如果需要读取最新的数据，可以使用 `FOR UPDATE` 或 `LOCK IN SHARE MODE` 来使用当前读。
- 当执行 `INSERT`、`UPDATE`、`DELETE` 等写入操作时，使用的是当前读，即直接操作数据库中当前的数据状态。

选择快照读还是当前读取决策取决于应用程序的需求和隔离级别的要求。快照读可以提供更高的并发性和隔离性，但当前读能够提供更接近实时的数据状态。

假设有两个事务，事务A和事务B，它们同时访问一个表中的某一行数据。我们假设初始时，数据如下：

```
| ID | Name  | Balance |
|----|-------|---------|
| 1  | Alice | 100     |
```

现在，事务A和事务B同时开始：

1. **事务A**：
    - 事务A读取当前数据，创建了自己的Read-View。
    - 事务A执行一条更新语句，将余额减少到50。

2. **事务B**：
    - 事务B也读取当前数据，创建了自己的Read-View。
    - 事务B执行一条更新语句，将余额增加到150。

现在我们来分析具体过程：

- 当事务A读取数据时，它会创建自己的 Read-View，用于确定事务开始时数据库中的数据状态。因此，事务A读取到的余额是100，这是事务开始时的数据状态。这是一个快照读。
- 当事务A执行更新操作时，它会使用当前读，因为事务A需要确保更新的数据是基于最新的数据状态的。它执行的更新操作将余额减少到50。
- 由于事务A正在进行更新操作，所以事务B在执行更新操作之前必须等待。在这段等待期间，事务B仍然使用它开始时创建的 Read-View 来读取数据。它读取到的余额也是100，这也是一个快照读。
- 当事务B执行更新操作时，它也使用当前读。它执行的更新操作将余额增加到150。

综上所述，事务A和事务B在并发修改数据时，每个事务都会创建自己的 Read-View 来读取数据，以确保事务开始时读取的是一致的数据快照。而在执行更新操作时，它们都会使用当前读，以确保更新的数据是基于最新的数据状态。

### 一致性锁定读和一致性非锁定读

一致性非锁定读（Consistent Non-locking Reads）和一致性锁定读（Consistent Locking Reads）也是两种读取数据的方式，与快照读和当前读相比，主要探讨读操作是否锁定被读取的数据。

1. **一致性非锁定读**(快照读)：

- 在一致性非锁定读中，数据库系统不会为读取操作设置任何锁，因此也称为非锁定读（Non-locking Read）。
- 在这种读取方式下，事务可以读取数据而不会阻塞其他事务的读取或写入操作。
- 一致性非锁定读通常用于读取事务中不需要严格一致性的数据，或者对读取的数据的即时性要求不高的情况。

2. **一致性锁定读**：

- 一致性锁定读是通过设置适当的锁来确保读取的数据在整个事务过程中保持一致性的读取方式。
- 通常会使用共享锁（Shared Lock）来保证其他事务可以同时读取数据，但阻止其他事务对数据进行修改。
- 这种读取方式确保了数据在读取过程中的一致性，因为其他事务无法修改被读取的数据，直到当前事务完成。
- 一致性锁定读适用于对读取的数据要求严格一致性的场景，尤其是在并发环境下保证读取的数据不被其他事务修改的情况下。

select for update - 对读取的记录加一个X锁,其他事务不能对已锁定的行加上任何锁,不影响读操作  
select lock in share mode - 对锁定的记录加一个S锁,其他事务可以加S锁,不能加X锁

总的来说，一致性非锁定读适用于对数据的即时性要求不高的情况下，而一致性锁定读适用于对数据一致性要求较高的情况下，尤其是在并发环境中需要保证数据的一致性。

### 自增长与锁

1. innodb 中对每个含有自增长值的表都有一个自增长计数器, 当对含有自增长的计数器的表进行插入操作的时候, 这个计数器会被初始化:
    - select max(auto_inc_col) from t for update
    - 插入操作会依据这个自增长的计数器值加 1 赋予自增长列, 这个实现方式叫做 AUTO-INC Locking, 这个锁会在事务内的每一个 insert语句执行完之后释放, 而不是在整个事务结束时释放
2. innodb_autoinc_lock_mode 参数
    - 0 - 对于所有的 insert 都采用 AUTO-INC Locking, 会持有锁一直到语句结束
    - 1 - 对于 simple insert 采用 mutex 对计数器进行访问, 拿到释放锁, 这个对于复制来说是安全的, 可以一次性拿到确定数目的自增 ID
    - 2 - 对于所有类型的 insert 都采用 mutex 来, 性能最好, 但是不安全, 对于同一个 insert 来说, 得到的 auto_increment 可能不是连续的
      这是因为如果基于语句复制, 在数据库 A执行的时候 语句 1先获得 id, 语句 2后获得 id, 而在数据库 B执行的时候是语句 2先获得 id, 所以会导致数据不一致

- Q: id什么时候会出现自增不连续?
- A: 1. 插入的事务回滚会导致不连续(包括主动回滚和主键冲突报错) 2. 批量插入, 这个由 mysql自增 ID获取策略导致, id申请呈 2的指数倍增长, 插入的数据非 2的倍数时会导致 id不连续自增
  其他 id 的生成方法: 雪花算法 //todo - 2023/03/07
- Q: 自增 id用完了怎么办
- A: 1. 改自增 id的类型, int 可以改为 bigint 2. 如果没有设置自增 id, 那么问题比较麻烦, 数据库会默认使用自己生成的一个 row_id, 超出后会从 0开始计算, 导致新插入的数据覆盖原有的数据

### InnoDB 的 MVCC 机制

1. **版本号**：
    - 每个事务在执行修改操作时都会分配一个唯一的事务ID（Transaction ID），用于标识该事务的提交顺序。这些事务ID被用来构建数据的不同版本。

2. **版本链**：
    - 对于每一行数据，在每次修改时都会创建一个新版本，并将该版本与对应的事务ID关联起来。这些版本被组织成一个版本链，形成了数据的不同历史版本。

3. **Read-View**：
    - 当事务开始时，会创建一个 Read-View，用于确定事务开始时数据库中数据的状态。Read-View 包含了当前事务的事务ID以及其他已提交事务的最大事务ID。
    - 在执行读取操作时，事务只能看到比自己的事务ID小或等于自己事务ID的数据版本，这样可以确保事务在读取数据时不会看到未提交的修改，从而实现了事务的隔离性。
    - 快照读sql 执行时 mvcc提取数据的依据, 就是在执行查询 sql的时候一个事务表, 通过事务表和数据保存的事务信息, 来判断当前的 sql应该获取哪个时刻的数据才是安全的
      m_ids - 当前活跃的事务编号, 还没有被提交的事务
      min_trx_id - 最小活跃事务编号
      max_trx_id - 预分配事务编号, 当前最大的事务编号 + 1
      creator_trx_id - ReadView创建者的事务编号
    - 可重复读和读提交 - 基于 undo_log 的版本链, 在表内会额外的增加两个字段 trx_id(这数据属于哪个事务编号, 修改操作的事务编号), db_roll_ptr(指向上一个进行版本变化时的数据镜像)
        1. 判断当前事务编号是否等于 creator_trx_id, 成立说明是当前事务更改的, 直接返回 - 也就是说, 第一步判断当前数据库的数据是不是当前事务所修改的, 自己修改的数据自己肯定可以访问的
        2. 判断 trx_id < min_trx_id, 成立说明数据已经提交, 可以返回 - 这个说明我们的 ReadView 最小的事务都要比这个数据的事务小, 对于当前的我们来说, 这个数据百分百安全
        3. 判断 trx_id > max_trx_id, 成立则说明事务是在 ReadView 生成之后才开启的, 不允许访问数据 - 当前数据库里的数据, 是在我们的 ReadView 生成之后才被提交过,
           我们不能在过去查看未来的数据, 所以是不可以用这个数据的
        4. 判断 min_trx_id <= trx_id <= max_trx_id, 成立则在 m_ids 对比, 如果不存在数据则代表是已提交的, 可以访问 - 这个数据如果是在最小事务和最大事务之间修改的,
           就是说这个数据是在这个 ReadView 被创建的期间被改的,
           如果不在活跃事务里, 就说明数据对于当前的 ReadView 来说安全, 当然可以访问
           读提交(RC)每次都会生成 ReadView 来获取数据, 也就意味着, 在同一个事务内, 会出现不可重复读
           可重复读(RR)仅在第一次会生成 ReadView, 之后都会复用这个 ReadView, 所以这意味着避免了不可重复读和幻读
           但是有特例, 在同一个事务内, 两次快照读中间穿插一次当前读会导致幻读, 这种情况, 会在第二次快照读的时候重新创建 ReadView
           案例: 在第一次查询的时候创建 ReadView, 然后事务二新插入了一条数据并提交成功, 事务一更新全表数据的某个字段, 然后执行查询操作这时就产生了幻读

4. **Read-View 的隔离级别**：
    - 不同的隔离级别会影响 Read-View 的创建方式和数据可见性。例如，在 Read Committed 隔离级别下，Read-View 只会包含当前事务开始时已提交的事务的最大事务ID；而在 Repeatable Read
      隔离级别下，Read-View
      会在事务执行期间保持不变，即使其他事务提交也不会改变它。

可以想象有一张表，其中包含一行数据，例如：

```
| ID | Name   | Age |
|----|--------|-----|
| 1  | Alice  | 30  |
```

假设有两个事务 T1 和 T2，它们分别对相同的行进行了修改。每次对行的修改都会产生一个新版本。例如，T1 和 T2 分别对 Age 字段进行了修改，形成了如下的版本链：

```
Initial State: 
| ID | Name   | Age |
|----|--------|-----|
| 1  | Alice  | 30  |

After T1:
| ID | Name   | Age |
|----|--------|-----|
| 1  | Alice  | 35  |  (T1 修改 Age)

After T2:
| ID | Name   | Age |
|----|--------|-----|
| 1  | Alice  | 40  |  (T2 修改 Age)
```

在这个示例中，每个版本都与对应的事务关联起来。当一个事务开始时，它会创建一个 Read-View，该 Read-View 包含了事务开始时数据库中已提交的数据的版本。根据隔离级别的不同，Read-View
可能会包含更旧的或更新的版本。例如，Repeatable Read 隔离级别下，T1 和 T2
在执行期间始终看到它们开始时的版本，即 T1 看到 Age 是 30，而 T2 看到 Age 是 35。

通过版本链和 Read-View，InnoDB 实现了 MVCC 机制，从而能够在高并发环境下提供高性能的事务支持。