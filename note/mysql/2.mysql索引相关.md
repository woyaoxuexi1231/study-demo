# 索引的基础知识

## 为何引入B+树

影响查询数据快慢的因素

1. 查询的数据总量较大  查询数量这个点无法解决  :x:
2. 查询的次数较多 查询次数确实可以解决的点 :white_check_mark:



二分查找/hash表(hash冲突之后会导致查询效率下降) 

:arrow_down:

二叉树(无序也不太行)

:arrow_down:

二叉排序树(如果插入数据顺序排列,就会导致树的高度太高)

:arrow_down:

平衡二叉树(用插入的成本来弥补查询的效率,插入情况特别多的话,要保持平衡需要更多的消耗)

:arrow_down:

红黑树[最长子树不超过最短子树的两倍即可,更多特性,为了解决AVL的过度平衡问题] (数据量过大也会使树的深度过大,我们需要跳脱出二叉树的想法)

:arrow_down:

B树(由于数据存储在每个结点上，假设每次IO取16kb的数据，这样使得我们每个结点保存的索引会更少，为了让每次IO读取的索引尽可能的多，引入B+树)

:arrow_down:

B+树(除叶子结点外，其他的结点只存储指针和索引值，这样可以存储更多的索引，每次IO能够查找更多的结点)



所以对于主键索引，innodb基于b+树，会把索引值存在非叶子结点，数据全部存在叶子结点上。
对于非主键索引，其他索引的叶子结点只存储主键值，再通过主键值来找到数据。

所以基于B+树的这种特性，IO次数在两三次的时候就能知道大概几千万到几亿的数据量，这种效率是非常高的。而表结构的数量最好也不要超过这个数字。

## B树与B+树的区别

B树：满足下列要求的m叉树

1. 树中每个结点至多有m个孩子结点(即至多有m-1个关键字)
2. 每个结点的结构为: n,p0,k1,p1,k2,...,kn,pn p为指向子树的指针,k为关键字,n代表有多少个结点
3. 除根结点外,其他结点至少有m/2个孩子结点
4. 若根节点不是叶子结点,则根节点至少有两个孩子结点
5. 所有叶子结点都在同一层上,即B树是所有结点的平衡因子均等于0的多路查找树

B树（B-tree）和B+树（B+ tree）是两种常见的数据结构，用于实现在磁盘或其他大容量存储设备上的索引结构，常用于数据库系统中。它们之间的主要区别在于其内部节点和叶子节点的结构以及搜索方式。下面是它们的主要区别：

1. **节点结构**：
    - **B树**：B树的每个节点既可以是内部节点，也可以是叶子节点。内部节点存储键值对和子节点的指针，叶子节点存储键值对和相关数据的指针。
    - **B+树**：B+树的内部节点只存储键值对，不存储数据指针，所有的数据都存储在叶子节点中。叶子节点通过指针连接形成链表。

2. **叶子节点**：
    - **B树**：在B树中，叶子节点存储了实际的数据，叶子节点之间通过指针连接。
    - **B+树**：B+树的叶子节点只存储键值对，数据存储在叶子节点中形成的链表中，叶子节点之间通过指针连接形成了一个有序链表。

3. **搜索方式**：
    - **B树**：在B树中，搜索可以从根节点开始，逐级向下查找，如果在内部节点中找到了键值，则根据键值指示的指针进入下一级节点，直到找到目标数据或者叶子节点。
    - **B+树**：B+树的搜索也是从根节点开始，但只有到达叶子节点时才找到目标数据，因为所有的数据都存储在叶子节点中。

4. **范围查询性能**：
    - **B树**：由于B树的叶子节点包含了数据，范围查询时需要在叶子节点之间进行遍历，性能可能不如B+树。
    - **B+树**：B+树的叶子节点形成了一个有序链表，范围查询时只需要在链表上进行遍历，性能更高。

总的来说，B+树相较于B树在范围查询上具有更好的性能，适用于大多数需要在磁盘或其他大容量存储设备上进行索引的场景。而B树在某些特定场景下可能会有一些优势，比如需要频繁地执行范围查询和局部查询的情况。

下面是一个简单的示意图，分别展示了B树和B+树的结构：

```
B树示意图：

          [20, 50]
         /    |    \
     [5,10] [30] [60, 70]
     /  |  \          |
 [2,3] [6] [15]       [65, 80]

B+树示意图：

          [20, 50]
         /    |    \
      [5]  [30]  [60]
      / \     |    | \
    [2,3][6,15]  |  [65, 80]
                 |
                [70]
```

在上面的示意图中，方框表示节点，方框内的数字表示节点存储的键值对。箭头表示节点之间的指针连接。在B树中，每个节点既可以是内部节点，也可以是叶子节点；而在B+树中，内部节点只存储键值对，所有的数据都存储在叶子节点中形成的链表中。

## 聚簇索引和非聚簇索引

聚簇索引（Clustered Index）和非聚簇索引（Non-clustered Index）是数据库中常见的两种索引类型，它们在数据组织方式和查询性能上有所不同。

**聚簇索引（Clustered Index）：**

1. **介绍：** 聚簇索引将数据行物理地存储在索引的顺序中。换句话说，表的数据行按照索引的键值顺序进行排序，并且每个表只能有一个聚簇索引。

2. **特点：**
    - 聚簇索引决定了表的物理存储顺序，因此，表的数据实际上就是按照索引顺序存储的。
    - 由于数据行按照索引顺序存储，因此对于范围查询等操作具有良好的性能。
    - 插入、更新、删除数据时，数据库引擎可能会调整数据行的物理位置，这可能会引起性能开销。

**非聚簇索引（Non-clustered Index）：**

1. **介绍：** 非聚簇索引将索引键值与数据行的物理存储分开。在非聚簇索引下，索引结构与实际数据的物理存储结构是分离的，一个表可以有多个非聚簇索引。

2. **特点：**
    - 索引结构和实际数据的物理存储是分离的，因此索引的顺序与数据行的顺序不一定相同。
    - 非聚簇索引一般会包含指向数据行的指针，这样当查询命中索引后，需要再次通过指针定位到实际的数据行。
    - 由于索引和数据行物理存储分开，因此非聚簇索引适用于经常进行插入、更新、删除操作的表，因为这些操作不会对索引的顺序造成大的影响。

**聚簇索引与非聚簇索引的区别：**

1. **物理存储方式：** 聚簇索引将数据行按照索引键值的顺序进行物理存储，而非聚簇索引则将索引结构与数据行的物理存储分开。

2. **数据访问方式：** 聚簇索引直接决定了数据行的物理存储顺序，因此对于范围查询等操作具有良好的性能；而非聚簇索引需要先通过索引找到数据行的指针，再根据指针访问实际的数据行，因此可能会引入额外的开销。

3. **适用场景：** 聚簇索引适用于经常进行范围查询等操作的表，而非聚簇索引适用于经常进行插入、更新、删除操作的表。

总的来说，聚簇索引和非聚簇索引各有其适用的场景，数据库设计时需要根据实际需求来选择合适的索引类型。

## 什么是覆盖索引

覆盖索引是指一个查询的所有所需数据都可以从索引中直接获取，而无需访问实际的数据行。换句话说，覆盖索引包含了查询所需的所有列，因此查询可以完全通过索引来执行，而不需要去访问表的数据行。这种情况下，查询可以在内存中直接进行索引扫描，而无需进行磁盘I/O操作，从而提高了查询性能。

覆盖索引通常发生在以下两种情况下：

1. 查询只涉及到索引列，并且索引包含了查询所需的所有列。
2. 查询使用了索引的列来进行过滤、排序或者分组，但不需要访问表的其他列。

使用覆盖索引可以提高查询性能的原因有以下几点：

- 减少了对数据行的访问：查询可以直接在索引中进行，而无需访问表的数据行，从而避免了额外的磁盘I/O操作。
- 减少了内存消耗：由于查询只需要加载索引而不是整个数据行，因此减少了内存的使用，特别是对于大型表而言，可以节省大量的内存。
- 减少了锁竞争：在某些情况下，使用覆盖索引可以减少对表的锁定，提高并发性能。

需要注意的是，并非所有的查询都适合使用覆盖索引，因为索引包含的列可能不足以满足查询的需求。因此，在设计索引时，需要根据实际的查询模式和需求来选择合适的索引策略。



# InnoDB范围查询支持索引吗

B+树的所有数据都存在叶子节点，并且数据是按顺序存储的，这样使得范围查找、排序查找更加方便
例如，如果你执行一个范围查询，如SELECT * FROM table WHERE id > 100 AND id < 200，InnoDB会首先在B+树中找到键值为100的节点，然后沿着叶子节点的链表结构顺序访问，直到键值达到200
此外，由于B+树的高度通常很低（通常只有2-4层），因此即使是范围查询，也只需要少数的磁盘I/O操作1。

范围查找也可能失效: 如果是非主键的范围查找,mysql可能会根据实际的情况来选择是否使用索引了,如果范围过大,走索引反而可能因为回表次数过多甚至比全表扫描的时间更多,这个时候索引就不管用了

# 为什么要遵守最左前缀原则呢?

B+树索引是一种多路搜索树，用于支持高效的数据检索操作。我将尝试为您描述一个简单的B+树索引结构，以便更好地理解。

假设我们有一个复合索引（a, b, c），现在来绘制一个包含一些示例数据的B+树索引结构。

首先，让我们考虑以下示例数据：

- (a=10, b=20, c=30)
- (a=10, b=25, c=35)
- (a=15, b=30, c=40)
- (a=20, b=40, c=50)

在B+树索引中，节点分为内部节点和叶子节点。内部节点存储键值范围和指向子节点的指针，而叶子节点存储实际的索引键值和指向数据行的引用或指针。

下面是一个简化的B+树示意图：

```
                             +----------------------------+
                             |             (10,*)         |
                             +----------------------------+
                            /                              \
        +---------------+                                  +---------------+
        | (10,*)        |                                  | (15,*)        |
        +---------------+                                  +---------------+
       /                  \                                /                \
+---------------+   +---------------+              +---------------+   +---------------+
| (10,20,30)    |   | (10,25,35)    |              | (15,30,40)    |   | (20,40,50)    |
+---------------+   +---------------+              +---------------+   +---------------+
```

- 每个内部节点包含了键值范围和指向子节点的指针。例如，第一个内部节点包含了键值范围 (10, *)，表示大于等于10的所有数据。
- 叶子节点存储了实际的索引键值和指向数据行的引用。例如，叶子节点包含了键值 (10, 20, 30)，表示具有a=10、b=20和c=30的数据行。

请注意，此示意图仅为简化版本，并不完全反映真实的B+树结构。实际上，B+树可能会有更多的节点和更多的层级，具体取决于索引键的数量和数据的分布。

**如果不遵循最左前缀原则,相当于从一开始就不知道从哪里开始,所以肯定就走不了索引了**

# order by 为什么会导致索引失效

和范围查找让索引失效是一个道理

# 哪些字段应该考虑创建索引，哪些字段尽量不要创建索引

在数据库设计和索引创建中，通常应该考虑以下几个方面来确定哪些字段应该创建索引，哪些字段尽量不要创建索引：

**应该考虑创建索引的字段**：

1. **经常用于查询的字段**：如果某个字段在查询条件或连接条件中频繁被使用，那么为该字段创建索引可以提高查询性能。
2. **唯一性约束字段**：对于需要唯一性约束的字段，如主键、唯一约束等，通常应该为其创建索引。
3. **经常用于排序和分组的字段**：如果某个字段经常用于ORDER BY、GROUP BY等操作，创建索引可以提高排序和分组性能。
4. **外键字段**：外键字段通常也应该创建索引，以提高关联表的连接查询性能。

**尽量不要创建索引的字段**：

1. **低选择性的字段**：如果某个字段的选择性很低，即字段值重复率很高，为其创建索引的效果会很差。
2. **频繁更新的字段**：如果某个字段经常被更新，那么频繁更新索引会增加维护成本，影响性能。
3. **小数据量字段**：对于数据量很小的字段，如性别、状态等，创建索引的效果通常不明显，可能会带来不必要的开销。
4. **不会被用于查询的字段**：对于不会在查询中使用到的字段，创建索引是没有意义的。

综上所述，应该结合具体的业务需求和数据访问模式来决定哪些字段应该创建索引，避免过多或无效的索引对系统性能和存储空间造成影响。定期监控和优化索引是保持数据库性能的重要一环。



# 什么是索引下推

好的，我来帮你详细讲讲 **索引下推（Index Condition Pushdown, ICP）** —— 这个是数据库（特别是 MySQL/InnoDB）里很典型的优化技术。

------

## 📌 1️⃣ 什么是索引下推（ICP）？

**索引下推**，全称 **Index Condition Pushdown**，是一种优化手段，它允许数据库在 **索引遍历阶段** 就对部分 WHERE 条件进行过滤，而不是等到通过索引找到数据行后再回表到数据页进行过滤。

ICP 是从 MySQL 5.6 开始引入的，主要针对 **二级索引**（非聚簇索引）的回表操作。

------

## 📌 2️⃣ ICP 出现前是怎么执行查询的？

传统的索引查询过程（以二级索引为例）：

1️⃣ 扫描索引 B+ 树，找到满足索引条件的索引记录（只包含索引列）。
 2️⃣ 对于满足索引条件的每条记录，去主键索引（聚簇索引）中回表读取整行数据。
 3️⃣ 回表后，再对剩余的 WHERE 条件做进一步判断。

⚡ **问题：** 如果 WHERE 里有的条件是索引里就包含的，但没在索引的索引条件里用上，没办法在索引扫描阶段就过滤，结果就是会读很多行回表，然后发现其实不满足，又丢弃了，造成不必要的 I/O。

------

## 📌 3️⃣ ICP 是怎么优化的？

**ICP 的核心点：**
 在索引扫描阶段，就把 **能在索引中判断的 WHERE 条件** 一起下推到索引遍历过程中，提前过滤掉一部分不符合条件的记录，减少回表次数。

✅ **什么时候能下推？**

- 条件必须只涉及索引中已有的列。
- 条件不能是复杂的需要表数据才能判断的（比如 `WHERE col1 > 10 AND col2 = 'abc'`，如果索引只包含 col1 和 col2，就可以下推）。

------

## 📌 4️⃣ 举个简单的例子

假设：

```sql
CREATE TABLE user (
  id INT PRIMARY KEY,
  age INT,
  gender CHAR(1),
  KEY idx_age_gender (age, gender)
);

-- 查询
SELECT * FROM user WHERE age > 30 AND gender = 'M';
```

- 如果没有 ICP，可能只用到 `age > 30` 来定位索引范围，然后找到符合 `age` 的记录后去回表，再判断 `gender`。
- 有了 ICP，`gender = 'M'` 也能在索引里判断，直接在索引遍历阶段过滤掉不满足的，减少回表行数。

------

## 📌 5️⃣ ICP 的原理简单说就是：

- 解析器将 WHERE 条件拆分为：
   👉 一部分是索引条件（用来确定索引扫描的范围）。
   👉 一部分是可下推条件（在索引遍历时能继续过滤的条件）。
   👉 剩余必须回表才能判断的条件（如有）。

------

## 📌 6️⃣ ICP 的优势

✅ **1. 降低回表次数**
 最直接，回表是随机 I/O，代价比单纯扫描索引页高得多。

✅ **2. 提高查询性能**
 更少的 I/O、更少的行处理，性能提升可观。

✅ **3. 对组合索引特别有效**
 当只使用了索引的部分列来定位范围时，其余列也可以用来过滤。

------

## 📌 7️⃣ ICP 是为了解决什么问题？

ICP 的主要目的是：

> **降低不必要的回表 I/O** —— 在索引扫描阶段尽可能筛掉不符合条件的数据。

ICP 的出现是为了让**存储引擎**在扫描索引时也能做尽可能多的过滤，而不是把所有过滤都留给**SQL执行器**在回表后做。

------

## 📌 8️⃣ 有什么限制吗？

- ICP 只在二级索引上有显著意义，对聚簇索引（主键索引）没用，因为本来就已经在读取数据行了。
- 复杂的表达式（比如函数、OR 连接条件、非索引列条件）不能下推。
- ICP 开启与否是由优化器自动决定，也可以通过 `EXPLAIN` 看执行计划里是否使用了 `Using index condition`。

------

## 📌 总结一句话

> **索引下推 = 在索引层面把能过滤的条件尽量过滤掉，尽可能减少回表，提升查询效率。**

------





# 联合索引

好问题！这也是很多人用 MySQL 时最容易忽略但又非常重要的核心点。
 我帮你详细分两块讲：**联合索引是如何存储的**，以及**如何写查询才能“吃满”联合索引的效果**。

------

## 📌 1️⃣ 联合索引是如何存储的？

MySQL 的联合索引（组合索引），其实是 **多列值按顺序拼接** 后，存储在同一个 B+ 树中的。

举个例子：

```sql
CREATE TABLE user (
  id INT PRIMARY KEY,
  age INT,
  gender CHAR(1),
  city VARCHAR(20),
  KEY idx_age_gender_city (age, gender, city)
);
```

这个 `idx_age_gender_city` 的底层 B+ 树存储的每个索引项，就像：

```
(age, gender, city) => 主键值
```

索引项按 **先 age、再 gender、再 city** 的字典序排列，内部结构是：

```
(age1, gender1, city1)  
(age1, gender1, city2)  
(age1, gender2, city1)  
(age2, gender1, city1)
...
```

所以本质是 **多列值拼成一个复合排序键**。

------

## 📌 2️⃣ 为什么联合索引顺序很重要？

因为 B+ 树的顺序决定了能否快速定位范围：

- 按索引第 1 列（age）查，一定能命中索引；
- 按索引前 2 列（age, gender）查，也能精准命中；
- 按索引第 3 列（city）单独查，一般用不上（除非 `city` 前面两个条件是常量，或者用到索引覆盖）。

这就是所谓的 **最左前缀原则（Leftmost Prefix Rule）**。

------

## 📌 3️⃣ 什么是最左前缀匹配？

**MySQL 联合索引只能从最左列开始连续使用。**

- ✅ 能用到索引的情况：
  - `WHERE age = 30`
  - `WHERE age = 30 AND gender = 'M'`
  - `WHERE age = 30 AND gender = 'M' AND city = 'Beijing'`
  - `WHERE age = 30 AND city = 'Beijing'`（只要前缀连续，中间不跳列，这个其实没用到 gender）
- ❌ 用不到索引：
  - `WHERE gender = 'M'` （跳过了 age，最左列不匹配）
  - `WHERE city = 'Beijing'`（跳了前两列）
  - `WHERE gender = 'M' AND city = 'Beijing'`（跳了 age）

------

## 📌 4️⃣ 最左前缀还支持范围查询，但有坑

如果中间列是范围，会截断：

例如：

```sql
WHERE age = 30 AND gender > 'M' AND city = 'Beijing'
```

这里：

- age = 30：命中
- gender > 'M'：是范围
- city = 'Beijing'：**会失效**

因为一旦范围（不等于、>、<、BETWEEN、LIKE 'abc%'）出现，后面的列就不能继续用于范围扫描了。

------

## 📌 5️⃣ 如何最大化发挥联合索引作用？

👉 **小结一条黄金原则：**
 **WHERE 中匹配列的顺序，要尽量连续覆盖联合索引的最左前缀，且把区分度高的列放前面。**

🔑 小技巧：

- 等值匹配列尽量放在前面，范围匹配列放后面。
- 如果有 ORDER BY，用上索引列的顺序可以避免 filesort。

------

## 📌 6️⃣ EXPLAIN 如何判断是否命中联合索引？

可以用：

```sql
EXPLAIN SELECT * FROM user WHERE age = 30 AND gender = 'M';
```

看 `key` 字段是 `idx_age_gender_city`，`rows` 很小，并且 `Extra` 没有 `Using where` 或者 `Using filesort`，说明利用得很好。

------

## 📌 7️⃣ 如果 SELECT 只读索引覆盖到的列，还能避免回表

比如：

```sql
SELECT age, gender FROM user WHERE age = 30 AND gender = 'M';
```

因为 `age` 和 `gender` 都在索引里，InnoDB 可以直接用索引叶子节点返回数据，不用回表查主键索引。这就是 **覆盖索引（Covering Index）**。

------

## 📌 8️⃣ 小结

✅ **联合索引本质：**
 多列值按顺序组成一个联合排序键，存储在 B+ 树里。

✅ **生效关键：**
 查询时条件要匹配最左前缀，并且尽量连续。

✅ **优化点：**
 设计索引时把高区分度列放前面、常用过滤列放前面；写 SQL 时要遵循最左匹配原则。

------

# explain+ICP分析

## 📌 1️⃣ EXPLAIN 到底是干啥用的？

`EXPLAIN` 是 MySQL 提供的执行计划分析工具，用来告诉你：

✅ MySQL 是怎么执行这条 SQL 的（比如走哪个索引）
 ✅ 每一步访问了多少行（估算）
 ✅ 是否做了回表
 ✅ 是否使用了 ICP（Index Condition Pushdown）
 ✅ 是否使用了覆盖索引
 ✅ 是否用了 filesort（额外的排序操作）
 ✅ 是否使用了临时表

这就相当于 **把优化器执行 SQL 的思路** 全部摊开在你面前。

------

## 📌 2️⃣ EXPLAIN 输出的核心字段含义

当你执行：

```sql
EXPLAIN SELECT * FROM user WHERE age = 30 AND gender = 'M';
```

会输出一张表，典型字段含义如下：

| 字段            | 含义                                                         |
| --------------- | ------------------------------------------------------------ |
| `id`            | 执行顺序标识，同一个 SQL 里如果有多张表 JOIN，会有多行 ID    |
| `select_type`   | 查询类型（SIMPLE, PRIMARY, SUBQUERY, UNION 等）              |
| `table`         | 访问的表                                                     |
| `partitions`    | 用到的分区（有分区表时才显示）                               |
| `type`          | 连接类型（system, const, eq_ref, ref, range, index, ALL）越靠左性能越好 |
| `possible_keys` | 可能用到的索引                                               |
| `key`           | 实际使用的索引                                               |
| `key_len`       | 实际使用索引长度                                             |
| `ref`           | 哪个列或常数与索引进行比较                                   |
| `rows`          | 估算扫描的行数                                               |
| `filtered`      | 按条件过滤后剩余百分比（近似）                               |
| `Extra`         | 额外信息，ICP、Using index、Using where、Using filesort、Using temporary |

------

## 📌 3️⃣ ICP（索引下推）怎么体现？

看 `Extra` 列：

- 如果看到 `Using index condition`，就是开启了 **ICP**。
   ➜ 表示某些 WHERE 条件已经在索引遍历阶段被过滤掉了。
- 如果只有 `Using where`，则表示是在回表后过滤。
- 如果有 `Using index`，说明用到了 **覆盖索引**（即不需要回表，只靠索引就能返回结果）。

举个示例对比：

**🌟 场景 1：只有索引条件**

```sql
EXPLAIN SELECT * FROM user WHERE age = 30;
```

可能 Extra: `Using where`
 （只用到索引的第一个列，索引只是确定范围，剩下的过滤是回表做）

------

**🌟 场景 2：有 ICP**

```sql
EXPLAIN SELECT * FROM user WHERE age = 30 AND gender = 'M';
```

- 如果 `gender` 在索引里，且没有用来做范围扫描（只是过滤），MySQL 会把 `gender = 'M'` 下推。
- 这时 `Extra` 会出现：`Using index condition`

------

**🌟 场景 3：覆盖索引**

```sql
EXPLAIN SELECT age, gender FROM user WHERE age = 30 AND gender = 'M';
```

- 如果 `SELECT` 的列都在索引里，Extra 会是：

  ```
  Using index condition; Using index
  ```

- `Using index` 表示是覆盖索引（不会回表），`Using index condition` 表示用了 ICP。

------

## ✅ EXPLAIN 演示的实际流程

比如你有下面这张表和索引：

```sql
CREATE TABLE user (
  id INT PRIMARY KEY,
  age INT,
  gender CHAR(1),
  city VARCHAR(20),
  KEY idx_age_gender (age, gender)
);
```

**SQL 1:**

```sql
EXPLAIN SELECT * FROM user WHERE age > 20 AND gender = 'M';
```

- `age > 20`：范围条件

- `gender = 'M'`：ICP

- 结果里 `Extra` 会显示：

  ```
  Using index condition; Using where
  ```

  - `index condition` = gender 在索引层过滤
  - `where` = 可能还有别的条件需要回表判断（比如 SELECT * 返回了主键以外列）。

------

## 📌 4️⃣ 怎么看执行计划好不好？

一个执行计划是否健康，常看这几点：
 ✅ `type` 不要是 `ALL`（ALL = 全表扫描）
 ✅ `key` 是你期望的索引
 ✅ `rows` 越小越好（意味着过滤效果好）
 ✅ `Extra` 没有 `Using filesort`（表示无需额外排序）
 ✅ `Extra` 没有 `Using temporary`（表示没有创建临时表）
 ✅ 有 `Using index` 说明覆盖索引命中
 ✅ 有 `Using index condition` 说明 ICP 生效

------

## 📌 5️⃣ 怎么调试 ICP 和索引覆盖？

可以对比几种写法：

| SQL                                                | Extra                              | 是否 ICP | 是否覆盖索引 |
| -------------------------------------------------- | ---------------------------------- | -------- | ------------ |
| SELECT * WHERE age = 20                            | Using where                        | ❌        | ❌            |
| SELECT * WHERE age = 20 AND gender = 'M'           | Using index condition              | ✅        | ❌            |
| SELECT age, gender WHERE age = 20 AND gender = 'M' | Using index condition; Using index | ✅        | ✅            |

------

## 🔑 总结一句话

👉 **EXPLAIN = 拆解 SQL 执行过程的放大镜**
 👉 **看 ICP = 看 `Extra` 有没有 `Using index condition`**
 👉 **看覆盖索引 = 看 `Extra` 有没有 `Using index`**
 👉 **想让索引用得值回票价 = 条件写法、SELECT 列要“配合”索引列**

------

# 联合索引 + ICP + 覆盖索引示例

------

## 🎯 **示例场景**

假设我们有这样一个表 `user`：

```sql
CREATE TABLE user (
  id INT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(20),
  age INT,
  gender CHAR(1),
  city VARCHAR(20),
  KEY idx_age_gender_city (age, gender, city)
);
```

联合索引：`(age, gender, city)`

------

## 🌟 **准备样例数据**

```sql
INSERT INTO user (name, age, gender, city) VALUES
('Alice', 25, 'F', 'Beijing'),
('Bob', 30, 'M', 'Shanghai'),
('Charlie', 30, 'M', 'Beijing'),
('Diana', 40, 'F', 'Shenzhen'),
('Eric', 35, 'M', 'Guangzhou');
```

------

## 📌 **1️⃣ 只用到索引第 1 列**

```sql
EXPLAIN SELECT * FROM user WHERE age = 30;
```

**执行计划大概长这样：**

| id   | select_type | table | type | key                 | key_len | ref   | rows | Extra       |
| ---- | ----------- | ----- | ---- | ------------------- | ------- | ----- | ---- | ----------- |
| 1    | SIMPLE      | user  | ref  | idx_age_gender_city | 5       | const | 2    | Using where |

**解析：**

- `type` = ref（等值匹配）
- `key` = 用了联合索引
- `rows` = 2（age = 30 有 2 行）
- `Extra` = Using where（只用 age 做了索引匹配，剩下过滤靠回表）

------

## 📌 **2️⃣ 用到索引第 1 列 + 第 2 列，触发 ICP**

```sql
EXPLAIN SELECT * FROM user WHERE age = 30 AND gender = 'M';
```

**执行计划大概：**

| id   | select_type | table | type  | key                 | key_len | ref  | rows | Extra                 |
| ---- | ----------- | ----- | ----- | ------------------- | ------- | ---- | ---- | --------------------- |
| 1    | SIMPLE      | user  | range | idx_age_gender_city | 5       | NULL | 2    | Using index condition |

**解析：**

- `type` = range（age 是范围或等值）
- `key` = idx_age_gender_city
- `Extra` = Using index condition
   ➜ 说明 `gender = 'M'` 被下推到索引扫描阶段了。
- `Using where` 没有单独显示，因为已经在索引层过滤了 `gender`。

------

## 📌 **3️⃣ 用到索引第 1 列 + 第 2 列 + 第 3 列**

```sql
EXPLAIN SELECT * FROM user WHERE age = 30 AND gender = 'M' AND city = 'Beijing';
```

| id   | select_type | table | type | key                 | key_len | ref               | rows | Extra       |
| ---- | ----------- | ----- | ---- | ------------------- | ------- | ----------------- | ---- | ----------- |
| 1    | SIMPLE      | user  | ref  | idx_age_gender_city | 64      | const,const,const | 1    | Using where |

**解析：**

- `type` = ref（多个等值匹配）
- `key_len` = 所有列都命中
- `rows` = 1（只匹配一行）
- `Extra` = Using where（这里可能 ICP 没啥可下推的，因为都是等值，直接匹配了。）

------

## 📌 **4️⃣ 用覆盖索引，避免回表**

如果只查询索引包含的列：

```sql
EXPLAIN SELECT age, gender, city FROM user WHERE age = 30 AND gender = 'M' AND city = 'Beijing';
```

| id   | select_type | table | type | key                 | key_len | ref               | rows | Extra                    |
| ---- | ----------- | ----- | ---- | ------------------- | ------- | ----------------- | ---- | ------------------------ |
| 1    | SIMPLE      | user  | ref  | idx_age_gender_city | 64      | const,const,const | 1    | Using where; Using index |

**解析：**

- `Using index` 出现 ➜ 说明是**覆盖索引**（只从索引树读数据，不用回表）。
- 查询效率更高，磁盘 I/O 更少。

------

## 📌 **5️⃣ 如果写个范围查询，会截断后面的索引列**

```sql
EXPLAIN SELECT * FROM user WHERE age > 20 AND gender = 'M' AND city = 'Beijing';
```

| id   | select_type | table | type  | key                 | key_len | ref  | rows | Extra                 |
| ---- | ----------- | ----- | ----- | ------------------- | ------- | ---- | ---- | --------------------- |
| 1    | SIMPLE      | user  | range | idx_age_gender_city | 5       | NULL | 5    | Using index condition |

**解析：**

- `age > 20` 是范围条件 ➜ 后面的 `gender = 'M'` 还能下推（ICP）。
- `city` 就不能再用作索引匹配了 ➜ 因为范围条件会截断联合索引的连续匹配。

------

## 📌 **6️⃣ 联合索引在 B+ 树中的结构**

可以想象存储顺序像这样：

| age  | gender | city      | 主键 id |
| ---- | ------ | --------- | ------- |
| 25   | F      | Beijing   | 1       |
| 30   | M      | Beijing   | 3       |
| 30   | M      | Shanghai  | 2       |
| 35   | M      | Guangzhou | 5       |
| 40   | F      | Shenzhen  | 4       |

联合索引的本质就是一个按 `(age, gender, city)` 排序的有序集合。
 一旦跳过前缀，就没法高效定位范围了。

------

## ✅ **这张表你该怎么记？**

| 点           | 解释                                 |
| ------------ | ------------------------------------ |
| ICP          | `Extra` 出现 `Using index condition` |
| 覆盖索引     | `Extra` 出现 `Using index`           |
| 是否命中索引 | `key` 是否是预期索引                 |
| 是否回表     | 没有 `Using index` 就需要回表        |
| 最左前缀原则 | 只能连续用索引列                     |
| 范围会截断   | 出现范围条件，后面的列失效           |

------

## 🗂️ **小结**

✅ **EXPLAIN = 调试索引的放大镜**
 ✅ **ICP = 提前过滤，省回表**
 ✅ **覆盖索引 = 直接用索引数据页返回，不走主键页**
 ✅ **最左前缀原则 = 别跳列！**
 ✅ **范围条件 = 截断后续列匹配**

------

