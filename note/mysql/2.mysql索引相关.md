## 索引的基础知识

### 为何引入B+树

影响查询数据快慢的因素: 1.查询的数据总量较大 2.查询的次数较多  
查询数量这个点无法解决  
查询次数确实可以解决的点 二分查找/hash表(hash冲突之后会导致查询效率下降)->二叉树(无序也不太行)
->二叉排序树(如果插入数据顺序排列,就会导致树的高度太高)->平衡二叉树(用插入的成本来弥补查询的效率,插入情况特别多的话,要保持平衡需要更多的消耗)
->红黑树[最长子树不超过最短子树的两倍即可,更多特性,为了解决AVL的过度平衡问题] (数据量过大也会使树的深度过大,我们需要跳脱出二叉树的想法)
->B树(由于数据存储在每个结点上,假设每次IO取16kb的数据,这样使得我们每个结点保存的索引会更少,为了让每次IO读取的索引尽可能的多,引入B+树)
->B+树(除叶子结点外,其他的结点只存储指针和索引值,这样可以存储更多的索引,每次IO能够查找更多的结点)

所以对于主键索引,innodb基于b+树,会把索引值存在非叶子结点.数据全部存在叶子结点上.
对于非主键索引,其他索引的叶子结点只存储主键值,再通过主键值来找到数据.

所以基于B+树的这种特性,IO次数在两三次的时候就能知道大概几千万到几亿的数据量,这种效率是非常高的.而表结构的数量最好也不要超过这个数字.

### B树与B+树的区别

B树:满足下列要求的m叉树
(1)树中每个结点至多有m个孩子结点(即至多有m-1个关键字)
(2)每个结点的结构为: n,p0,k1,p1,k2,...,kn,pn p为指向子树的指针,k为关键字,n代表有多少个结点
(3)除根结点外,其他结点至少有m/2个孩子结点
(4)若根节点不是叶子结点,则根节点至少有两个孩子结点
(5)所有叶子结点都在同一层上,即B树是所有结点的平衡因子均等于0的多路查找树

B树（B-tree）和B+树（B+ tree）是两种常见的数据结构，用于实现在磁盘或其他大容量存储设备上的索引结构，常用于数据库系统中。它们之间的主要区别在于其内部节点和叶子节点的结构以及搜索方式。下面是它们的主要区别：

1. **节点结构**：
    - **B树**：B树的每个节点既可以是内部节点，也可以是叶子节点。内部节点存储键值对和子节点的指针，叶子节点存储键值对和相关数据的指针。
    - **B+树**：B+树的内部节点只存储键值对，不存储数据指针，所有的数据都存储在叶子节点中。叶子节点通过指针连接形成链表。

2. **叶子节点**：
    - **B树**：在B树中，叶子节点存储了实际的数据，叶子节点之间通过指针连接。
    - **B+树**：B+树的叶子节点只存储键值对，数据存储在叶子节点中形成的链表中，叶子节点之间通过指针连接形成了一个有序链表。

3. **搜索方式**：
    - **B树**：在B树中，搜索可以从根节点开始，逐级向下查找，如果在内部节点中找到了键值，则根据键值指示的指针进入下一级节点，直到找到目标数据或者叶子节点。
    - **B+树**：B+树的搜索也是从根节点开始，但只有到达叶子节点时才找到目标数据，因为所有的数据都存储在叶子节点中。

4. **范围查询性能**：
    - **B树**：由于B树的叶子节点包含了数据，范围查询时需要在叶子节点之间进行遍历，性能可能不如B+树。
    - **B+树**：B+树的叶子节点形成了一个有序链表，范围查询时只需要在链表上进行遍历，性能更高。

总的来说，B+树相较于B树在范围查询上具有更好的性能，适用于大多数需要在磁盘或其他大容量存储设备上进行索引的场景。而B树在某些特定场景下可能会有一些优势，比如需要频繁地执行范围查询和局部查询的情况。

下面是一个简单的示意图，分别展示了B树和B+树的结构：

```
B树示意图：

          [20, 50]
         /    |    \
     [5,10] [30] [60, 70]
     /  |  \          |
 [2,3] [6] [15]       [65, 80]

B+树示意图：

          [20, 50]
         /    |    \
      [5]  [30]  [60]
      / \     |    | \
    [2,3][6,15]  |  [65, 80]
                 |
                [70]
```

在上面的示意图中，方框表示节点，方框内的数字表示节点存储的键值对。箭头表示节点之间的指针连接。在B树中，每个节点既可以是内部节点，也可以是叶子节点；而在B+树中，内部节点只存储键值对，所有的数据都存储在叶子节点中形成的链表中。

### 聚簇索引和非聚簇索引

聚簇索引（Clustered Index）和非聚簇索引（Non-clustered Index）是数据库中常见的两种索引类型，它们在数据组织方式和查询性能上有所不同。

**聚簇索引（Clustered Index）：**

1. **介绍：** 聚簇索引将数据行物理地存储在索引的顺序中。换句话说，表的数据行按照索引的键值顺序进行排序，并且每个表只能有一个聚簇索引。

2. **特点：**
    - 聚簇索引决定了表的物理存储顺序，因此，表的数据实际上就是按照索引顺序存储的。
    - 由于数据行按照索引顺序存储，因此对于范围查询等操作具有良好的性能。
    - 插入、更新、删除数据时，数据库引擎可能会调整数据行的物理位置，这可能会引起性能开销。

**非聚簇索引（Non-clustered Index）：**

1. **介绍：** 非聚簇索引将索引键值与数据行的物理存储分开。在非聚簇索引下，索引结构与实际数据的物理存储结构是分离的，一个表可以有多个非聚簇索引。

2. **特点：**
    - 索引结构和实际数据的物理存储是分离的，因此索引的顺序与数据行的顺序不一定相同。
    - 非聚簇索引一般会包含指向数据行的指针，这样当查询命中索引后，需要再次通过指针定位到实际的数据行。
    - 由于索引和数据行物理存储分开，因此非聚簇索引适用于经常进行插入、更新、删除操作的表，因为这些操作不会对索引的顺序造成大的影响。

**聚簇索引与非聚簇索引的区别：**

1. **物理存储方式：** 聚簇索引将数据行按照索引键值的顺序进行物理存储，而非聚簇索引则将索引结构与数据行的物理存储分开。

2. **数据访问方式：** 聚簇索引直接决定了数据行的物理存储顺序，因此对于范围查询等操作具有良好的性能；而非聚簇索引需要先通过索引找到数据行的指针，再根据指针访问实际的数据行，因此可能会引入额外的开销。

3. **适用场景：** 聚簇索引适用于经常进行范围查询等操作的表，而非聚簇索引适用于经常进行插入、更新、删除操作的表。

总的来说，聚簇索引和非聚簇索引各有其适用的场景，数据库设计时需要根据实际需求来选择合适的索引类型。

### 什么是覆盖索引

覆盖索引是指一个查询的所有所需数据都可以从索引中直接获取，而无需访问实际的数据行。换句话说，覆盖索引包含了查询所需的所有列，因此查询可以完全通过索引来执行，而不需要去访问表的数据行。这种情况下，查询可以在内存中直接进行索引扫描，而无需进行磁盘I/O操作，从而提高了查询性能。

覆盖索引通常发生在以下两种情况下：

1. 查询只涉及到索引列，并且索引包含了查询所需的所有列。
2. 查询使用了索引的列来进行过滤、排序或者分组，但不需要访问表的其他列。

使用覆盖索引可以提高查询性能的原因有以下几点：

- 减少了对数据行的访问：查询可以直接在索引中进行，而无需访问表的数据行，从而避免了额外的磁盘I/O操作。
- 减少了内存消耗：由于查询只需要加载索引而不是整个数据行，因此减少了内存的使用，特别是对于大型表而言，可以节省大量的内存。
- 减少了锁竞争：在某些情况下，使用覆盖索引可以减少对表的锁定，提高并发性能。

需要注意的是，并非所有的查询都适合使用覆盖索引，因为索引包含的列可能不足以满足查询的需求。因此，在设计索引时，需要根据实际的查询模式和需求来选择合适的索引策略。

## 索引相关的一些问题

### innodb是如何让范围查询也支持索引的?

B+树的所有数据都存在叶子节点，并且数据是按顺序存储的，这样使得范围查找、排序查找更加方便
例如，如果你执行一个范围查询，如SELECT * FROM table WHERE id > 100 AND id < 200，InnoDB会首先在B+树中找到键值为100的节点，然后沿着叶子节点的链表结构顺序访问，直到键值达到200
此外，由于B+树的高度通常很低（通常只有2-4层），因此即使是范围查询，也只需要少数的磁盘I/O操作1。

范围查找也可能失效: 如果是非主键的范围查找,mysql可能会根据实际的情况来选择是否使用索引了,如果范围过大,走索引反而可能因为回表次数过多甚至比全表扫描的时间更多,这个时候索引就不管用了

### 为什么要遵守最左前缀原则呢?

B+树索引是一种多路搜索树，用于支持高效的数据检索操作。我将尝试为您描述一个简单的B+树索引结构，以便更好地理解。

假设我们有一个复合索引（a, b, c），现在来绘制一个包含一些示例数据的B+树索引结构。

首先，让我们考虑以下示例数据：

- (a=10, b=20, c=30)
- (a=10, b=25, c=35)
- (a=15, b=30, c=40)
- (a=20, b=40, c=50)

在B+树索引中，节点分为内部节点和叶子节点。内部节点存储键值范围和指向子节点的指针，而叶子节点存储实际的索引键值和指向数据行的引用或指针。

下面是一个简化的B+树示意图：

```
                             +----------------------------+
                             |             (10,*)         |
                             +----------------------------+
                            /                              \
        +---------------+                                  +---------------+
        | (10,*)        |                                  | (15,*)        |
        +---------------+                                  +---------------+
       /                  \                                /                \
+---------------+   +---------------+              +---------------+   +---------------+
| (10,20,30)    |   | (10,25,35)    |              | (15,30,40)    |   | (20,40,50)    |
+---------------+   +---------------+              +---------------+   +---------------+
```

- 每个内部节点包含了键值范围和指向子节点的指针。例如，第一个内部节点包含了键值范围 (10, *)，表示大于等于10的所有数据。
- 叶子节点存储了实际的索引键值和指向数据行的引用。例如，叶子节点包含了键值 (10, 20, 30)，表示具有a=10、b=20和c=30的数据行。

请注意，此示意图仅为简化版本，并不完全反映真实的B+树结构。实际上，B+树可能会有更多的节点和更多的层级，具体取决于索引键的数量和数据的分布。

**如果不遵循最左前缀原则,相当于从一开始就不知道从哪里开始,所以肯定就走不了索引了**

### order by 为什么会导致索引失效

和范围查找让索引失效是一个道理

### 哪些字段应该考虑创建索引，哪些字段尽量不要创建索引

在数据库设计和索引创建中，通常应该考虑以下几个方面来确定哪些字段应该创建索引，哪些字段尽量不要创建索引：

**应该考虑创建索引的字段**：

1. **经常用于查询的字段**：如果某个字段在查询条件或连接条件中频繁被使用，那么为该字段创建索引可以提高查询性能。
2. **唯一性约束字段**：对于需要唯一性约束的字段，如主键、唯一约束等，通常应该为其创建索引。
3. **经常用于排序和分组的字段**：如果某个字段经常用于ORDER BY、GROUP BY等操作，创建索引可以提高排序和分组性能。
4. **外键字段**：外键字段通常也应该创建索引，以提高关联表的连接查询性能。

**尽量不要创建索引的字段**：

1. **低选择性的字段**：如果某个字段的选择性很低，即字段值重复率很高，为其创建索引的效果会很差。
2. **频繁更新的字段**：如果某个字段经常被更新，那么频繁更新索引会增加维护成本，影响性能。
3. **小数据量字段**：对于数据量很小的字段，如性别、状态等，创建索引的效果通常不明显，可能会带来不必要的开销。
4. **不会被用于查询的字段**：对于不会在查询中使用到的字段，创建索引是没有意义的。

综上所述，应该结合具体的业务需求和数据访问模式来决定哪些字段应该创建索引，避免过多或无效的索引对系统性能和存储空间造成影响。定期监控和优化索引是保持数据库性能的重要一环。
