### 为何引入B+树

影响查询数据快慢的因素: 1.查询的数据总量较大 2.查询的次数较多  
查询数量这个点无法解决  
查询次数确实可以解决的点 二分查找/hash表(hash冲突之后会导致查询效率下降)->二叉树(无序也不太行)
->二叉排序树(如果插入数据顺序排列,就会导致树的高度太高)->平衡二叉树(用插入的成本来弥补查询的效率,插入情况特别多的话,要保持平衡需要更多的消耗)
->红黑树[最长子树不超过最短子树的两倍即可,更多特性,为了解决AVL的过度平衡问题] (数据量过大也会使树的深度过大,我们需要跳脱出二叉树的想法)
->B树(由于数据存储在每个结点上,假设每次IO取16kb的数据,这样使得我们每个结点保存的索引会更少,为了让每次IO读取的索引尽可能的多,引入B+树)
->B+树(除叶子结点外,其他的结点只存储指针和索引值,这样可以存储更多的索引,每次IO能够查找更多的结点)

### B树与B+树的区别

B树:满足下列要求的m叉树
(1)树中每个结点至多有m个孩子结点(即至多有m-1个关键字)
(2)每个结点的结构为: n,p0,k1,p1,k2,...,kn,pn p为指向子树的指针,k为关键字,n代表有多少个结点
(3)除根结点外,其他结点至少有m/2个孩子结点
(4)若根节点不是叶子结点,则根节点至少有两个孩子结点
(5)所有叶子结点都在同一层上,即B树是所有结点的平衡因子均等于0的多路查找树

B树（B-tree）和B+树（B+ tree）是两种常见的数据结构，用于实现在磁盘或其他大容量存储设备上的索引结构，常用于数据库系统中。它们之间的主要区别在于其内部节点和叶子节点的结构以及搜索方式。下面是它们的主要区别：
 
1. **节点结构**：
    - **B树**：B树的每个节点既可以是内部节点，也可以是叶子节点。内部节点存储键值对和子节点的指针，叶子节点存储键值对和相关数据的指针。
    - **B+树**：B+树的内部节点只存储键值对，不存储数据指针，所有的数据都存储在叶子节点中。叶子节点通过指针连接形成链表。

2. **叶子节点**：
    - **B树**：在B树中，叶子节点存储了实际的数据，叶子节点之间通过指针连接。
    - **B+树**：B+树的叶子节点只存储键值对，数据存储在叶子节点中形成的链表中，叶子节点之间通过指针连接形成了一个有序链表。

3. **搜索方式**：
    - **B树**：在B树中，搜索可以从根节点开始，逐级向下查找，如果在内部节点中找到了键值，则根据键值指示的指针进入下一级节点，直到找到目标数据或者叶子节点。
    - **B+树**：B+树的搜索也是从根节点开始，但只有到达叶子节点时才找到目标数据，因为所有的数据都存储在叶子节点中。

4. **范围查询性能**：
    - **B树**：由于B树的叶子节点包含了数据，范围查询时需要在叶子节点之间进行遍历，性能可能不如B+树。
    - **B+树**：B+树的叶子节点形成了一个有序链表，范围查询时只需要在链表上进行遍历，性能更高。

总的来说，B+树相较于B树在范围查询上具有更好的性能，适用于大多数需要在磁盘或其他大容量存储设备上进行索引的场景。而B树在某些特定场景下可能会有一些优势，比如需要频繁地执行范围查询和局部查询的情况。

下面是一个简单的示意图，分别展示了B树和B+树的结构：

```
B树示意图：

          [20, 50]
         /    |    \
     [5,10] [30] [60, 70]
     /  |  \          |
 [2,3] [6] [15]       [65, 80]

B+树示意图：

          [20, 50]
         /    |    \
      [5]  [30]  [60]
      / \     |    | \
    [2,3][6,15]  |  [65, 80]
                 |
                [70]
```

在上面的示意图中，方框表示节点，方框内的数字表示节点存储的键值对。箭头表示节点之间的指针连接。在B树中，每个节点既可以是内部节点，也可以是叶子节点；而在B+树中，内部节点只存储键值对，所有的数据都存储在叶子节点中形成的链表中。