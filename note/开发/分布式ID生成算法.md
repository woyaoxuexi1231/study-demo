## 自增主键

分布式场景下的自增id,多个不同库的

## UUID

**8345579d-c4d1-4295-958a-13fbd85cc397**

uuid通常由 八位-四位-四位-四位-十二位 组成,其实是由 128位二进制数组成,<br>
对于不同版本的UUID，各部分的含义和目的有所差异，主要基于UUID生成时所使用的算法。下面是各个版本UUID具体各部分的解释：

> 时间戳是 1724673875462 有13位

### 版本 1：基于时间戳的UUID

这个版本的时间戳与上述的时间戳是不一样的,UUID版本1的时间戳是一个60位的值，它表示自公元1582年10月15日以来的100纳秒间隔数。

60位的时间戳变成16进制也有15位数

- **字段 1：时间戳的低位部分** (8 位)
- **字段 2：时间戳的中位部分** (4 位)
- **字段 3：时间戳的高位部分，并包括UUID版本号** (4 位，第一位表示版本)
- **字段 4：时钟序列，并包括变体的信息** (2位时钟序列高位 + 2位时钟序列低位，高四位)
- **字段 5：节点ID** (通常是MAC地址，12 位)

### 版本 2：不提供详细的公开定义

### 版本 3：基于名称和MD5散列的UUID

- **字段 1：散列生成的部分** (8 位)
- **字段 2：散列生成的部分** (4 位)
- **字段 3：散列生成的部分，包含UUID版本号** (4 位，其中最高位两个数字表示UUID版本)
- **字段 4：散列生成的部分** (4 位)
- **字段 5：散列生成的部分** (12 位)

### 版本 4：随机生成的UUID

- **字段 1：随机生成的数字** (8 位)
- **字段 2：随机生成的数字** (4 位)
- **字段 3：随机生成的数字但包含UUID版本号** (4 位，其中最高位两个数字表示UUID版本)
- **字段 4：随机生成的数字，包含变体信息** (4 位，其中最高位的几位包含变体信息)
- **字段 5：随机生成的数字** (12 位)

### 版本 5：基于名称和SHA-1散列的UUID

- **字段 1：散列生成的部分** (8 位)
- **字段 2：散列生成的部分** (4 位)
- **字段 3：散列生成的部分，包含UUID版本号** (4 位，其中最高位两个数字表示UUID版本)
- **字段 4：散列生成的部分** (4 位)
- **字段 5：散列生成的部分** (12 位)

对于版本3和版本5的UUID，名称和命名空间是通过散列算法生成UUID的，所以它们在结构上与版本4相似，但生成算法和用途不同。版本3使用MD5散列算法，而版本5使用SHA-1散列算法。这些散列算法帮助确保从相同的输入名称和命名空间生成的UUID具有确定性和唯一性，即使在不同的执行间也是如此。

各版本 UUID 简要总结如下：<br>

**Version 1 和 Version 2：** 基于时间戳和 MAC 地址，适合分布式计算环境，具有高度唯一性。

**Version 3 和 Version 5：** 基于名称空间，在一定范围内是唯一的，可用于生成重复 UUID 的场景。

**Version 4：** 简单地基于随机数生成，适合数据量不是特别大的场景，但可靠性较低。

## 雪花算法

雪花算法,生成64bit的long类型整数
雪花算法由四部分组成 1位固定位(0)+41位时间戳+10位标识位+序列号

1. 最高位是符号位，0 表示正，1 表示负，固定为 0，如果是 1 就是负数了。
2. 存储毫秒级时间戳（41 位的长度可以使用 69 年）。
3. 机器id（5bit）和 服务id（5bit）统一叫作“标识位”，两个标识位组合起来最多可以支持部署 1024 个节点。也
4. 用于表示在同一毫秒内生成的多个ID的序号。如果在同一毫秒内生成的ID超过了4096个（2的12次方），则需要等到下一毫秒再生成ID。

时间回拨：时间同步错误导致（同步NTP服务器出现延迟、错误），时钟漂移（晶振随着时间推移发生飘逸，与NTP时间出现不一致）等其他原因

处理时间回拨问题：

1. hutool 超过两秒就直接报错了, 没超过两秒的检查上次