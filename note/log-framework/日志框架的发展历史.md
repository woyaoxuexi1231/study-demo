# System.out.println()

最初，Java程序使用`System.out.println()`来记录日志信息。这种方法虽然简单直接，但缺乏灵活性和控制力，不适合复杂的应用场景。

# log4j

1996年，Ceki Gülcü 开发了Log4j(log for java)，并将其捐赠给Apache软件基金会，这标志着Java日志记录进入了一个新阶段。Log4j 提供了丰富的特性，如日志级别、日志格式和日志输出目标等，迅速成为Java日志记录的事实标准。

```xml
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
    <version>1.2.17</version>
</dependency>
```

代码中可以通过两种方式来使用

1. LogManager.getLogger(Log4jExample.class)来获取日志记录器，
2. lombok.extern.log4j.Log4j注解

如果需要自定义日志的格式，需要准备一个log4j.properties的配置文件放在资源目录下（resources）

```properties
# 根日志记录器
# 只有级别为INFO及以上（包括WARN、ERROR、FATAL）的日志消息会被记录。
# 指定了两个输出目的地：控制台（stdout）和文件（file）。
log4j.rootLogger=INFO, stdout, file

# 控制台输出配置
# 定义了一个名为stdout的控制台输出目标，使用ConsoleAppender类。
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
# 设置控制台输出的日志格式，使用PatternLayout类。
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
# 定义了日志的具体格式
log4j.appender.stdout.layout.ConversionPattern=log4j %d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n

# 文件输出配置
# 定义了一个名为file的文件输出目标，使用RollingFileAppender类。这个类支持日志文件的滚动。
log4j.appender.file=org.apache.log4j.RollingFileAppender
# 指定日志文件的路径和名称。
log4j.appender.file.File=./log4j.log
# 设置每个日志文件的最大大小为1MB。
log4j.appender.file.MaxFileSize=1MB
# 设置最多保留5个备份文件。当当前日志文件达到最大大小时，会自动滚动到新的文件，旧的日志文件会被重命名并保存。
log4j.appender.file.MaxBackupIndex=5
# 设置文件输出的日志格式，使用PatternLayout类。
log4j.appender.file.layout=org.apache.log4j.PatternLayout
# 定义了日志的具体格式，与控制台输出的格式相同。
log4j.appender.file.layout.ConversionPattern=log4j %d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n
```

# Java Util Logging (JUL)

随后Apache想把log4j并入jdk遭到SUN公司的拒绝，2002年，Sun Microsystems（现Oracle）在JDK 1.4中引入了Java Util Logging (JUL)，作为Java平台的标准日志框架。尽管JUL与Java平台紧密集成，但在灵活性和功能上相比Log4j有所不足。

无需引入任何jar包就可以使用，使用方式：

1. 通过java.util.logging.Logger获取一个日志记录器。

2. lombok提供了lombok.extern.java.Log注解使用。

比较麻烦的是需要有加载配置文件的行为：

```java
static {
    try (InputStream inputStream = JulExample.class.getClassLoader().getResourceAsStream("logging.properties")) {
        if (inputStream != null) {
            LogManager.getLogManager().readConfiguration(inputStream);
            log.info("Logging configuration loaded successfully");
        } else {
            System.err.println("Could not find logging.properties file");
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

配置文件如下（如果需要自己配置的话）：

1. 定义了一个自定义的日志格式化类（可以不要）

   ```java
   import java.util.logging.Formatter;
   import java.util.logging.LogRecord;
   
   public class MyCustomFormatter extends Formatter {
   
       @Override
       public String format(LogRecord record) {
           return String.format("[%1$tF %1$tT] [%2$s] %3$s %n",
                   record.getMillis(),
                   record.getLevel().getLocalizedName(),
                   record.getMessage());
       }
   }
   ```

2. logging.properties配置文件用于配置详细的格式

   ```properties
   # 定义了使用的日志处理器（Handler）。JUL支持多种日志处理器，通常用于将日志输出到不同的目标。
   # java.util.logging.FileHandler：将日志写入文件。
   # java.util.logging.ConsoleHandler：将日志输出到控制台。
   # 所有的日志消息将会通过这两个处理器进行输出。
   handlers = java.util.logging.FileHandler, java.util.logging.ConsoleHandler
   
   # 控制台日志处理器的日志级别设置为ALL，意味着所有级别的日志都会输出到控制台。
   java.util.logging.ConsoleHandler.level = ALL
   # 这里使用了一个自定义的格式化器 com.hundun.demo.log.MyCustomFormatter，这意味着日志输出的格式将由该类来决定。
   # java.util.logging.SimpleFormatter，它是JUL提供的默认格式化器，用于将日志记录格式化为简单的文本形式。
   java.util.logging.ConsoleHandler.formatter = org.hulei.log.framework.MyCustomFormatter
   
   # 设置了根日志记录器的日志级别为INFO。
   # 这意味着，除非有更具体的日志级别设置（例如，针对特定包或类的配置），否则默认情况下，只有INFO级别及其以上（如WARNING, SEVERE）的日志信息会被记录。
   .level = INFO
   # 包级别的日志级别设置
   com.example.package1.level = INFO
   com.example.package2.level = FINE
   
   # 文件日志处理器的配置
   # 文件日志处理器的日志级别设置为INFO，即只有INFO级别及以上的日志才会被写入文件。
   java.util.logging.FileHandler.level = INFO
   # 指定日志文件的输出路径。./jul.log表示日志文件将被输出到当前工作目录下，文件名为jul.log
   java.util.logging.FileHandler.pattern = ./jul.log
   # 设置文件输出的日志格式化器为org.hulei.log.framework.MyCustomFormatter，这是一个自定义的格式化器，用于格式化日志的输出。
   java.util.logging.FileHandler.formatter = org.hulei.log.framework.MyCustomFormatter
   ```



# JCL（Jakarta Commons Logging）

为了解决多个日志框架在项目中的混用导致的维护混乱问题，Apache社区2002年提出了commons-logging即JCL的日志抽象来适配各种日志框架。JCL定义了一套日志接口，并支持运行时动态加载日志组件的实现，使得开发者可以在应用代码中只调用Commons Logging的接口，而底层实现可以是Log4j、JUL等。

```xml
<dependencies>
    <!-- 日志门面 -->
    <dependency>
        <groupId>commons-logging</groupId>
        <artifactId>commons-logging</artifactId>
        <version>1.2</version>
    </dependency>

    <!-- 如果要使用JUL作为底层实现，是没有必要引入这个包的 -->
    <!-- 引入了这个包之后，commons-logging会优先使用log4j而不是JUL -->
    <dependency>
        <groupId>log4j</groupId>
        <artifactId>log4j</artifactId>
        <version>1.2.17</version>
    </dependency>
</dependencies>
```

然后如果使用 commons-logging + JUL，JUL仍然需要手动加载配置文件才能正确的个性化配置。

代码层面：

1. org.apache.commons.logging.LogFactory 工厂获取日志输出类。
2. lombok.extern.apachecommons.CommonsLog 注解加上即可使用。



# Slf4j logback

Ceki Gülcü 后来与 Apache 基金会关于 Commons-Logging 制定的标准存在分歧, Ceki Gülcü 离开 Apache 后，2006年间前后分别创建了 Slf4j(Simple Logging Facade for Java,Java 的简单日志门面,同样支持log4j和JUL) 和 Logback(它是 SLF4J 的原生实现) 两个项目。Logback 具有比 Log4j 更好的性能，尤其是在多线程环境中，并且默认的配置和日志输出格式也做了很好的优化。

代码层面：

1. 使用org.slf4j.LoggerFactory构建日志输出类。
2. 直接使用lombok.extern.slf4j.Slf4j提供的。



SLF4j提供了非常强大的对于各种日志框架的适配能力：



![img](https://ask.qcloudimg.com/http-save/yehe-4300526/d8c2c6a64daa99b0c13997c9413f1358.png)

![img](https://ask.qcloudimg.com/http-save/yehe-4300526/46331fca7fa124df22a9df70f7d1870e.png)



如果你开发了一个组件，而且希望上层应用直接通过该组件的 GAV 信息来引入，那么在你这个组件中建议使用日志门面来记录日志，但往往事与愿违，很多开发者还是直接选择具体的日志系统来记录日志，这就有点不规范了。想象一下，如果上层应用使用的日志系统是 logback，而你的组件选用的日志系统却是 log4j，为了将整个应用的日志系统拉齐为 logback，此时你可以用 slf4j 提供的针对 log4j 的桥接模块去替换 log4j 依赖，这样你就不用修改任何代码。从这个例子中，大家可能猜到了桥接模块的作用，就是将面向特定日志系统的日志记录请求路由到 *slf4j-api* 中去。但有一点需要注意，针对同一款日志系统的绑定模块不能与桥接模块同时存在于当前应用的`classpath`中，否则会造成死循环！



![img](https://ask.qcloudimg.com/http-save/yehe-4300526/c85119aba6b90b8e9a1ada6acd11bd1b.png)



相关依赖：

```xml
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>1.7.32</version>
</dependency>
```

而slf4j作为日志门面框架，仅仅只是提供相关规范，而没有具体实现。

```xml
<dependencies>
    <!-- logback作为默认实现，不需要任何桥接包，支持很好 -->
    <dependency>
        <groupId>ch.qos.logback</groupId>
        <artifactId>logback-classic</artifactId>
        <version>1.2.6</version>
    </dependency>

    <!-- 
    slf4j当时为了适配JUL和log4j，还特意开发了与对应日志系统匹配的绑定模块，那么面向 slf4j-api 的日志记录请求最终会被路由到该日志系统中去。
    在绑定模块内，会实现slf4j的接口，然后这些实现类内部会依赖对应日志系统的实现类，在内部调用这些实现类的接口去记录日志，相当于适配器模式。
    -->

    <!-- JUL的绑定模块，这里我配置的时候出现了各种各样的问题，slf4j老是提示没有日志框架实现(Defaulting to no-operation (NOP) logger implementation)，IDEA抽风了，可能依赖缓存存在一点问题。 -->
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-jdk14</artifactId>
        <version>2.0.16</version>
    </dependency>

    <!-- slf4j绑定到log4j模块包 -->
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-log4j12</artifactId>
        <version>2.0.16</version>
    </dependency>
</dependencies>
```



对于其他日志的桥接模式：

举例：如果要把JUL的日志桥接到slf4j这里来，并且转发给log4j，可以使用如下配置。

- 对于依赖

  ```xml
  <dependencies>
        <!-- slf4j的api包 -->
      <dependency>
          <groupId>org.slf4j</groupId>
          <artifactId>slf4j-api</artifactId>
          <version>2.0.16</version>
      </dependency>
      
      <!-- slf4j绑定到log4j的模块实现 -->
      <dependency>
          <groupId>org.slf4j</groupId>
          <artifactId>slf4j-log4j12</artifactId>
          <version>2.0.16</version>
          <!-- 我这里排除了内部的api包，保持了版本统一(内部可能版本低，遇到了一些问题) -->
          <exclusions>
              <exclusion>
                  <groupId>org.slf4j</groupId>
                  <artifactId>slf4j-api</artifactId>
              </exclusion>
          </exclusions>
      </dependency>
      
      <!-- jul的日志会通过这个依赖被转发到slf4j的日志系统，再由slf4j指定的具体实现来打印日志 -->
      <dependency>
          <groupId>org.slf4j</groupId>
          <artifactId>jul-to-slf4j</artifactId>
          <version>2.0.16</version>
          <exclusions>
              <exclusion>
                  <groupId>org.slf4j</groupId>
                  <artifactId>slf4j-api</artifactId>
              </exclusion>
          </exclusions>
      </dependency>
  </dependencies>
  ```

- 代码内仍有配置

  ```java
  public class JulToSlf4jExample {
      public static void main(String[] args) {
          // 移除根记录器的现有处理程序
          org.slf4j.bridge.SLF4JBridgeHandler.removeHandlersForRootLogger();
          // 安装 SLF4JBridgeHandler，将 JUL 日志重定向到 SLF4J
          org.slf4j.bridge.SLF4JBridgeHandler.install();
      }
  }
  ```

上面两个配置好之后，由JUL输出的日志会被重定向到log4j打印出来。



logback日志实现的配置文件

```xml
<!-- Logback configuration. See http://logback.qos.ch/manual/index.html -->

<!--
scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。
scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒当scan为true时，此属性生效。默认的时间间隔为1分钟。
debug：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。
-->
<configuration scan="true" scanPeriod="2 seconds">

    <!--定义日志文件的存储地址-->
    <property name="LOG_PATH" value="./"/>

    <!-- 控制台输出 -->
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">

        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <!--格式化输出：%d表示日期，%-5level：级别从左显示5个字符宽度，%t表示线程名，%msg：日志消息，%n是换行符-->
            <pattern>logback %d{yy-MM-dd HH:mm:ss.SSS} %-5level ${PID:-} --- [%t] %logger{50} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- info级别日志文件输出 -->
    <appender name="INFO_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>INFO</level>
        </filter>
        <!-- 日志文件输出的文件名 -->
        <File>${LOG_PATH}/info.log</File>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <!-- 每日生成日志文件或日志文件大小超出限制后输出的文件名模板 -->
            <fileNamePattern>${LOG_PATH}/info-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <!-- 日志文件保留天数 -->
            <maxHistory>30</maxHistory>
            <!-- 日志文件最大大小：100MB -->
            <maxFileSize>100MB</maxFileSize>
        </rollingPolicy>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>logback %d{yy-MM-dd HH:mm:ss.SSS} %-5level ${PID:-} --- [%t] %logger{50} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- error级别日志文件输出 -->
    <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 日志输出级别，优先级 > '<root level>' -->
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>ERROR</level>
        </filter>
        <File>${LOG_PATH}/error.log</File>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/error-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <maxHistory>30</maxHistory>
            <maxFileSize>100MB</maxFileSize>
        </rollingPolicy>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>logback %d{yy-MM-dd HH:mm:ss.SSS} %-5level ${PID:-} --- [%t] %logger{50} - %msg%n</pattern>
        </encoder>
    </appender>


    <!--添加dao层的logger，打印level为debug，就可以打印sql-->
    <!--<logger name="org.hl.java.spring.mapper" level="DEBUG" />-->

    <!-- 默认日志输出级别 -->
    <root level="INFO">
        <appender-ref ref="STDOUT"/>
        <appender-ref ref="INFO_FILE"/>
        <appender-ref ref="ERROR_FILE"/>
    </root>


</configuration>
```





# Log4j2

为了维护在 Java 日志江湖的地位, 防止 JCL、Log4j 被 Slf4j、Logback 组合取代, 2014 年 Apache 推出了 Log4j2, Log4j2 与 log4j 不兼容, 经过大量深度优化, 其性能显著提升 。

现在主流的搭配就是 slf4j + log4j2 。

依赖：

```xml
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-core</artifactId>
    <version>2.23.1</version>
</dependency>
```

当然log4j2也提供了一些适配其他日志框架的桥接包。

- log4j2适配 JCL

  ```xml
  <dependencies>
      <dependency>
          <groupId>commons-logging</groupId>
          <artifactId>commons-logging</artifactId>
          <version>1.2</version>
      </dependency>
      <dependency>
          <groupId>org.apache.logging.log4j</groupId>
          <artifactId>log4j-jcl</artifactId>
          <version>2.23.1</version>
      </dependency>
      <dependency>
          <groupId>org.apache.logging.log4j</groupId>
          <artifactId>log4j-core</artifactId>
          <version>2.23.1</version>
      </dependency>
  </dependencies>
  ```

- log4j2适配slf4j

  ```xml
  <dependencies>
      <dependency>
          <groupId>org.slf4j</groupId>
          <artifactId>slf4j-api</artifactId>
          <version>2.0.16</version>
      </dependency>
      <dependency>
          <groupId>org.apache.logging.log4j</groupId>
          <artifactId>log4j-slf4j-impl</artifactId>
          <version>2.23.1</version>
          <exclusions>
              <exclusion>
                  <groupId>org.slf4j</groupId>
                  <artifactId>slf4j-api</artifactId>
              </exclusion>
          </exclusions>
      </dependency>
  </dependencies>
  ```

当然适配其他的。



# 配置文件

- log4j - log4j.properties
- logback - logback.xml
- jul - logging.properties
- log4j2 - log4j2.xml

# Spring Boot 日志框架

Spring Boot默认使用的日志框架是 Logback。
Spring Boot在所有内部日志中使用 Commons Logging，但是默认配置也提供了对常用日志的支持，如：Java Util Logging，Log4J, Log4J2和Logback。

spring-boot-starter-logging 依赖包括三个依赖
logback-classic(经典库, 提供了对 slf4j 的支持, 包含了 logback-core, slf4j-api)
log4j-to-slf4j(提供了 log4j 的日志消息到 SLF4j 的路由, 包含了 slf4j-api)
jul-to-slf4j(提供了 jul(java-util-logging) 到 slf4j 的支持, 依赖包含slf4j-api)



