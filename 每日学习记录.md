### 2024-02-20

> 1. 四层网络模型和七层网络模型 链路层(硬件,网卡)->网络层(IP)->传输层(TCP)->应用层(HTTP)
> 2. TCP协议(面向连接[建立连接后才开始进行传输],可靠交付[通过协议内定义的序列号,应答/重传],全双工[两端设有发送和接收缓存],面向字节流[数据以流的形式传输])和UDP协议 
> 3. TCP协议的三次握手[为什么需要发送确认回报呢?防止以失效的连接请求报文段]和四次挥手[双方都要确认连接关闭]
> 4. TCP协议是如何保证可靠的 - [滑动窗口,超时重传,选择确认]

### 2024-02-21

> 1. LeetCode[106]-从中序与后序遍历序列构建二叉树
> 2. 前序遍历, 中序遍历, 后续遍历 - 都相对于根节点来说,即根节点的前序,中序和后续

### 2024-02-22

> 1. LeetCode[889]-从前序和中序遍历序列构建二叉树

### 2024-02-23

> 1. [2583]二叉树中的第 K 大层和 - [广度优先搜索 + 排序]
> 2. 广度优先搜索[Breadth-First Search，简称BFS] 先进先出队列
> 3. 深度优先搜索[Depth-First Search，简称DFS]

### 2024-02-26

> 1. LeetCode [938] 二叉搜索树的范围和
> 2. 深度优先搜索[Depth-First Search，简称DFS]

### 2024-02-27

> 1. TODO LeetCode [2867] 统计树中的合法路径数目-不会做
> 2. review segment ID 生成算法
> 3. 线程池如何保证线程一直运行, 并等待新任务 [worker队列+阻塞循环获取任务]
> 4. 关于迭代器可以在循环时安全的安全的删除元素(不使用迭代器进行操作,是由于对数组本身进行删除会造成跳过元素或者重复处理元素) [next方法每次都会拷贝一次数组再取元素]
> 5. 安全失败(迭代过程中，即使底层的集合被修改了，迭代器仍然可以继续工作且不会抛出 ConcurrentModificationException 异常)[CopyOnWriteArrayList写时复制]和快速失败[ArrayList的modCount]
> 6. TODO HashMap

### 2024-02-28

> 1. LeetCode [2673] 使二叉树所有路径值相等的最小代价 - [自底向上 + 贪心]
> 2. 关于String的一些冷知识, String 是一个不可变的类，表示字符序列. 使用双引号 "" 创建字符串时，我们实际上是在直接使用一个字符串字面量

### 2024-02-29

> 1. 数据库碎片整理方案
> 2. TODO main为什么必须是静态的(涉及jvm)

### 2024-03-02

> 1. CopyOnWriteArrayList的原理(写时复制和最终一致性)
> 2. 动态绑定(（也称为晚期绑定或运行时多态性）是一种在运行时（而非编译时）确定要调用方法的对象的机制)
> 3. 工厂模式, 建造者模式, 单例模式(四种实现方式)
> 4. ReentrantLock(基于AbstractQueuedSynchronizer)加锁释放锁过程(源码)
> 5. 实现阻塞队列 [Object对象的wait()和notify()]或者[ArrayBlockingQueue]

### 2024-03-03

> 1. MySQL为什么使用可重复读作为数据库的默认隔离级别? [因为MySQL的可重复读就已经提供了最高级别的隔离, 解决了脏读,不可重复读和幻读]
> 2. MySQL是如何在可重复读级别下解决幻读问题的? [MVCC]
> 3. (实操)Linux 环境下如何查找哪个线程使用 CPU 最长
> 4. TODO 线程调度算法有哪些?
> 5. TODO 哪些情况可能会导致内存泄漏

### 2024-03-04

> 1. TODO LeetCode [2369] 检查数组是否存在有效划分
> 2. Java内存模型和Java的内存分区
> 3. GC的判定方法(引用计数法和可达性分析法(引用链法))
> 4. TODO SafePoint
> 5. TODO GC的三种收集算法
> 6. TODO 有哪些具体的GC收集器
> 7. 类的加载过程

### 2024-03-05

> 1. git分支切换实操

### 2024-03-08 - 2024-03-10

> 1. Java原生(servlet+jsp)+tomcat+html 架构的web应用架构,实现
> 2. ssm架构的web应用的架构,实现
> 3. springboot+模板语言/原生js+html 实现的web应用架构,实现
> 4. springboot+vue 实现的前后端分离的web应用架构,实现

### 2024-03-11

> 1. webSocket的三种实现方式 ①Java注解形式的原生websocket实现(基于spring) ②基于spring封装的websocket实现 ③基于spring+stomp的websocket实现
> 2. webSocket在 springboot + vue 的前后端分离的架构下的整合

### 2024-03-12

> 1. springboot中的rabbitmq的基本使用
> 2. 消息重复消费的解决方案
> 3. 消息幂等性(需要业务代码具备这种幂等性操作)
> 4. 消息的有序性(单一消费者模式,kafka分区顺序,RocketMQ顺序消息队列)

### 2024-03-13

> 1. spring多数据源解析
> 2. spring+mybatis多数据源解析

### 2024-03-14

> 1. 原生springmvc(配置文件加载bean)代码整理

### 2024-03-15

> 1. dubbo注册中心宕机,服务是否可用
> 2. log4j2配置debug级别日志

### 2024-03-16

> 1. 什么是RPC协议
> 2. 什么是dubbo
> 3. 分布式架构的解析

### 2024-03-17

> 1. dubbo的服务降级(mock)
> 2. dubbo的五种负载均衡策略

### 2024-03-18

> 1. 二分查找和选择排序复盘

### 2024-03-19

> 1. 快速排序复盘(双指针)
> 2. [leetcode-15] 三数之和(1.暴力 2.排序+双指针) -> [leetcode-1] 两数之和(1.暴力 2.哈希表)